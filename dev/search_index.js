var documenterSearchIndex = {"docs":
[{"location":"man/plotting/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"Survey uses AlgebraOfGraphics for plotting. All plotting functions support a variable number of keyword arguments (through kwargs...) that are passed internally to corresponding AlgebraOfGraphics functions. See the source code for details: plot, hist, boxplot. This means that all functionality provided by AlgebraOfGraphics is supported in Survey.","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"Specific functionality might need to be imported from AlgebraOfGraphics. Moreover, in order to choose the preferred Makie backend you must explicitly use it:","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"using AlgebraOfGraphics, CairoMakie","category":"page"},{"location":"man/replicate/#Replicate-weights","page":"Replicate weights","title":"Replicate weights","text":"","category":"section"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"Replicate weights are a method for estimating the standard errors of survey statistics in complex sample designs.","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"The basic idea behind replicate weights is to create multiple versions of the original sample weights, each with small, randomly generated perturbations. The multiple versions of the sample weights are then used to calculate the survey statistic of interest, such as the mean or total, on multiple replicate samples. The variance of the survey statistic is then estimated by computing the variance across the replicate samples.","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"Currently, the Rao-Wu bootstrap[1] is the only method in the package for generating replicate weights. ","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"The bootweights function of the package can be used to generate a ReplicateDesign from a SurveyDesign For example: ","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"using Survey\napistrat = load_data(\"apistrat\")\nstrat = SurveyDesign(apistrat; strata=:stype, weights=:pw)\nstrat_boot = bootweights(strat; replicates = 10)","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"For each replicate, the DataFrame of ReplicateDesign has an additional column. The of the column is replicate_ followed by the replicate number.  ","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"names(strat_boot.data)","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"replicate_1, replicate_2, replicate_3, replicate_4, replicate_5, replicate_6, replicate_7, replicate_8, replicate_9, replicate_10, are the replicate weight columns. ","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"While a SurveyDesign can be used to estimate a statistics. For example: ","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"mean(:api00, strat)","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"The ReplicateDesign can be used to compute the standard error of the statistic. For example: ","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"mean(:api00, strat_boot)","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"For each replicate weight, the statistic is calculated using it instead of the weight. The standard deviation of those statistics is the standard error of the estimate.  ","category":"page"},{"location":"man/replicate/#References","page":"Replicate weights","title":"References","text":"","category":"section"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"[1]: Rust, Keith F., and J. N. K. Rao. \"Variance estimation for complex surveys using replication techniques.\" Statistical methods in medical research 5.3 (1996): 283-310.","category":"page"},{"location":"api/#API","page":"API reference","title":"API","text":"","category":"section"},{"location":"api/#Index","page":"API reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Module = [Survey]\nOrder = [:type, :function]\nPrivate = false","category":"page"},{"location":"api/","page":"API reference","title":"API reference","text":"AbstractSurveyDesign\nSurveyDesign\nReplicateDesign\nload_data\nbootweights\nmean\ntotal\nquantile\nratio\nplot\nboxplot\nhist","category":"page"},{"location":"api/#Survey.AbstractSurveyDesign","page":"API reference","title":"Survey.AbstractSurveyDesign","text":"AbstractSurveyDesign\n\nSupertype for every survey design type. \n\nnote: Note\nThe data passed to a survey constructor is modified. To avoid this pass a copy of the data instead of the original.\n\n\n\n\n\n","category":"type"},{"location":"api/#Survey.SurveyDesign","page":"API reference","title":"Survey.SurveyDesign","text":"SurveyDesign <: AbstractSurveyDesign\n\nGeneral survey design encompassing a simple random, stratified, cluster or multi-stage design.\n\nIn the case of cluster sample, the clusters are chosen by simple random sampling. All individuals in one cluster are sampled. The clusters are considered disjoint and nested.\n\nstrata and clusters must be given as columns in data.\n\nArguments:\n\ndata::AbstractDataFrame: the survey dataset (!this gets modified by the constructor).\nstrata::Union{Nothing, Symbol}=nothing: the stratification variable.\nclusters::Union{Nothing, Symbol, Vector{Symbol}}=nothing: the clustering variable.\nweights::Union{Nothing, Symbol}=nothing: the sampling weights.\npopsize::Union{Nothing, Symbol}=nothing: the (expected) survey population size.\n\njulia> apiclus1 = load_data(\"apiclus1\");\n\njulia> dclus1 = SurveyDesign(apiclus1; clusters=:dnum, strata=:stype, weights=:pw)\nSurveyDesign:\ndata: 183×43 DataFrame\nstrata: stype\n    [H, E, E  …  E]\ncluster: dnum\n    [637, 637, 637  …  448]\npopsize: [507.7049, 507.7049, 507.7049  …  507.7049]\nsampsize: [15, 15, 15  …  15]\nweights: [33.847, 33.847, 33.847  …  33.847]\nallprobs: [0.0295, 0.0295, 0.0295  …  0.0295]\n\n\n\n\n\n","category":"type"},{"location":"api/#Survey.ReplicateDesign","page":"API reference","title":"Survey.ReplicateDesign","text":"ReplicateDesign <: AbstractSurveyDesign\n\nSurvey design obtained by replicating an original design using bootweights.\n\njulia> apistrat = load_data(\"apistrat\");\n\njulia> strat = SurveyDesign(apistrat; strata=:stype, weights=:pw);\n\njulia> bootstrat = bootweights(strat; replicates=1000)\nReplicateDesign:\ndata: 200×1044 DataFrame\nstrata: stype\n    [E, E, E  …  H]\ncluster: none\npopsize: [4420.9999, 4420.9999, 4420.9999  …  755.0]\nsampsize: [100, 100, 100  …  50]\nweights: [44.21, 44.21, 44.21  …  15.1]\nallprobs: [0.0226, 0.0226, 0.0226  …  0.0662]\nreplicates: 1000\n\n\n\n\n\n","category":"type"},{"location":"api/#Survey.load_data","page":"API reference","title":"Survey.load_data","text":"load_data(name)\n\nLoad a sample dataset as a DataFrame.\n\nAll available datasets can be found here.\n\njulia> apisrs = load_data(\"apisrs\")\n200×40 DataFrame\n Row │ Column1  cds             stype    name             sname                ⋯\n     │ Int64    Int64           String1  String15         String               ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │    1039  15739081534155  H        McFarland High   McFarland High       ⋯\n   2 │    1124  19642126066716  E        Stowers (Cecil   Stowers (Cecil B.) E\n   3 │    2868  30664493030640  H        Brea-Olinda Hig  Brea-Olinda High\n   4 │    1273  19644516012744  E        Alameda Element  Alameda Elementary\n   5 │    4926  40688096043293  E        Sunnyside Eleme  Sunnyside Elementary ⋯\n   6 │    2463  19734456014278  E        Los Molinos Ele  Los Molinos Elementa\n   7 │    2031  19647336058200  M        Northridge Midd  Northridge Middle\n   8 │    1736  19647336017271  E        Glassell Park E  Glassell Park Elemen\n  ⋮  │    ⋮           ⋮            ⋮            ⋮                       ⋮      ⋱\n 194 │    4880  39686766042782  E        Tyler Skills El  Tyler Skills Element ⋯\n 195 │     993  15636851531987  H        Desert Junior/S  Desert Junior/Senior\n 196 │     969  15635291534775  H        North High       North High\n 197 │    1752  19647336017446  E        Hammel Street E  Hammel Street Elemen\n 198 │    4480  37683386039143  E        Audubon Element  Audubon Elementary   ⋯\n 199 │    4062  36678196036222  E        Edison Elementa  Edison Elementary\n 200 │    2683  24657716025621  E        Franklin Elemen  Franklin Elementary\n                                                 36 columns and 185 rows omitted\n\n\n\n\n\n","category":"function"},{"location":"api/#Survey.bootweights","page":"API reference","title":"Survey.bootweights","text":"julia> using Random\n\njulia> apiclus1 = load_data(\"apiclus1\");\n\njulia> clus_one_stage = SurveyDesign(apiclus1; clusters = :dnum, popsize=:fpc);\n\njulia> bootweights(clus_one_stage; replicates=1000, rng=MersenneTwister(111)) # choose a seed for deterministic results\nReplicateDesign:\ndata: 183×1044 DataFrame\nstrata: none\ncluster: dnum\n    [61, 61, 61  …  815]\npopsize: [757, 757, 757  …  757]\nsampsize: [15, 15, 15  …  15]\nweights: [50.4667, 50.4667, 50.4667  …  50.4667]\nallprobs: [0.0198, 0.0198, 0.0198  …  0.0198]\nreplicates: 1000\n\n\n\n\n\n","category":"function"},{"location":"api/#Statistics.mean","page":"API reference","title":"Statistics.mean","text":"mean(var, design)\n\nEstimate the mean of a variable.\n\njulia> apiclus1 = load_data(\"apiclus1\");\n\njulia> clus_one_stage = SurveyDesign(apiclus1; clusters = :dnum, weights = :pw)\nSurveyDesign:\ndata: 183×44 DataFrame\nstrata: none\ncluster: dnum\n    [637, 637, 637  …  448]\npopsize: [507.7049, 507.7049, 507.7049  …  507.7049]\nsampsize: [15, 15, 15  …  15]\nweights: [33.847, 33.847, 33.847  …  33.847]\nallprobs: [0.0295, 0.0295, 0.0295  …  0.0295]\n\njulia> mean(:api00, clus_one_stage)\n1×1 DataFrame\n Row │ mean\n     │ Float64\n─────┼─────────\n   1 │ 644.169 \n\n\n\n\n\nUse replicate weights to compute the standard error of the estimated mean. \n\njulia> clus_one_stage_boot = clus_one_stage |> bootweights;\n\njulia> mean(:api00, clus_one_stage_boot)\n1×2 DataFrame\n Row │ mean     SE\n     │ Float64  Float64\n─────┼──────────────────\n   1 │ 644.169  23.4107\n\n\n\n\n\nEstimate the mean of a list of variables.\n\njulia> mean([:api00, :enroll], clus_one_stage)\n2×2 DataFrame\n Row │ names   mean\n     │ String  Float64\n─────┼─────────────────\n   1 │ api00   644.169\n   2 │ enroll  549.716\n\nUse replicate weights to compute the standard error of the estimated means. \n\njulia> mean([:api00, :enroll], clus_one_stage_boot)\n2×3 DataFrame\n Row │ names   mean     SE\n     │ String  Float64  Float64\n─────┼──────────────────────────\n   1 │ api00   644.169  23.4107\n   2 │ enroll  549.716  45.7835 \n\n\n\n\n\nmean(var, domain, design)\n\nEstimate means of domains.\n\njulia> mean(:api00, :cname, clus_one_stage)\n11×2 DataFrame\n Row │ cname        mean\n     │ String15     Float64\n─────┼──────────────────────\n   1 │ Alameda      669.0\n   2 │ Fresno       472.0\n   3 │ Kern         452.5\n   4 │ Los Angeles  647.267\n   5 │ Mendocino    623.25\n   6 │ Merced       519.25\n   7 │ Orange       710.563\n   8 │ Plumas       709.556\n   9 │ San Diego    659.436\n  10 │ San Joaquin  551.189\n  11 │ Santa Clara  732.077 \n\nUse the replicate design to compute standard errors of the estimated means. \n\njulia> mean(:api00, :cname, clus_one_stage_boot)\n11×3 DataFrame\n Row │ cname        mean     SE\n     │ String15     Float64  Float64\n─────┼────────────────────────────────────\n   1 │ Santa Clara  732.077  58.2169\n   2 │ San Diego    659.436   2.66703\n   3 │ Merced       519.25    2.28936e-15\n   4 │ Los Angeles  647.267  47.6233\n   5 │ Orange       710.563   2.19826e-13\n   6 │ Fresno       472.0     1.13687e-13\n   7 │ Plumas       709.556   1.26058e-13\n   8 │ Alameda      669.0     1.27527e-13\n   9 │ San Joaquin  551.189   2.1791e-13\n  10 │ Kern         452.5     0.0\n  11 │ Mendocino    623.25    1.09545e-13\n\n\n\n\n\n","category":"function"},{"location":"api/#Survey.total","page":"API reference","title":"Survey.total","text":"total(var, design)\n\nEstimate the population total of variable.\n\njulia> apiclus1 = load_data(\"apiclus1\");\n\njulia> clus_one_stage = SurveyDesign(apiclus1; clusters = :dnum, weights = :pw);\n\njulia> total(:api00, clus_one_stage)\n1×1 DataFrame\n Row │ total\n     │ Float64\n─────┼───────────\n   1 │ 3.98999e6\n\n\n\n\n\nUse replicate weights to compute the standard error of the estimated total. \n\njulia> clus_one_stage_boot = clus_one_stage |> bootweights;\n\njulia> total(:api00, clus_one_stage_boot)\n1×2 DataFrame\n Row │ total      SE\n     │ Float64    Float64\n─────┼──────────────────────\n   1 │ 3.98999e6  9.01611e5\n\n\n\n\n\nEstimate the population total of a list of variables.\n\njulia> total([:api00, :enroll], clus_one_stage)\n2×2 DataFrame\n Row │ names   total\n     │ String  Float64\n─────┼───────────────────\n   1 │ api00   3.98999e6\n   2 │ enroll  3.40494e6\n\nUse replicate weights to compute the standard error of the estimated means. \n\njulia> total([:api00, :enroll], clus_one_stage_boot)\n2×3 DataFrame\n Row │ names   total      SE\n     │ String  Float64    Float64\n─────┼──────────────────────────────\n   1 │ api00   3.98999e6  9.01611e5\n   2 │ enroll  3.40494e6  9.33396e5 \n\n\n\n\n\ntotal(var, domain, design)\n\nEstimate population totals of domains.\n\njulia> total(:api00, :cname, clus_one_stage)\n11×2 DataFrame\n Row │ cname        total\n     │ String15     Float64\n─────┼─────────────────────────────\n   1 │ Alameda      249080.0\n   2 │ Fresno        63903.1\n   3 │ Kern          30631.5\n   4 │ Los Angeles       3.2862e5\n   5 │ Mendocino     84380.6\n   6 │ Merced        70300.2\n   7 │ Orange            3.84807e5\n   8 │ Plumas            2.16147e5\n   9 │ San Diego         1.2276e6\n  10 │ San Joaquin       6.90276e5\n  11 │ Santa Clara       6.44244e5 \n\nUse the replicate design to compute standard errors of the estimated totals. \n\njulia> total(:api00, :cname, clus_one_stage_boot)\n11×3 DataFrame\n Row │ cname        total           SE\n     │ String15     Float64         Float64\n─────┼────────────────────────────────────────────\n   1 │ Santa Clara       6.44244e5      4.2273e5\n   2 │ San Diego         1.2276e6       8.62727e5\n   3 │ Merced        70300.2        71336.3\n   4 │ Los Angeles       3.2862e5       2.93936e5\n   5 │ Orange            3.84807e5      3.88014e5\n   6 │ Fresno        63903.1        64781.7\n   7 │ Plumas            2.16147e5      2.12089e5\n   8 │ Alameda      249080.0            2.49228e5\n   9 │ San Joaquin       6.90276e5      6.81604e5\n  10 │ Kern          30631.5        30870.3\n  11 │ Mendocino     84380.6        80215.9\n\n\n\n\n\n","category":"function"},{"location":"api/#Statistics.quantile","page":"API reference","title":"Statistics.quantile","text":"quantile(var, design, p; kwargs...)\n\nEstimate quantile of a variable.\n\nHyndman and Fan compiled a taxonomy of nine algorithms to estimate quantiles. These are implemented in Statistics.quantile, which this function calls. Julia, R and Python-numpy use the same defaults\n\nReferences:\n\nHyndman, R.J and Fan, Y. (1996) \"Sample Quantiles in Statistical Packages\", The American Statistician, Vol. 50, No. 4, pp. 361-365.\nQuantiles on wikipedia\nComplex Surveys: a guide to analysis using R, Section 2.4.1 and Appendix C.4.\n\njulia> apisrs = load_data(\"apisrs\");\n\njulia> srs = SurveyDesign(apisrs; weights=:pw); \n\njulia> quantile(:api00, srs, 0.5)\n1×1 DataFrame\n Row │ 0.5th percentile\n     │ Float64\n─────┼──────────────────\n   1 │            659.0\n\n\n\n\n\nUse replicate weights to compute the standard error of the estimated quantile. \n\njulia> srs_boot = srs |> bootweights; \n\njulia> quantile(:api00, srs_boot, 0.5)\n1×2 DataFrame\n Row │ 0.5th percentile  SE\n     │ Float64           Float64\n─────┼───────────────────────────\n   1 │            659.0  14.9764\n\n\n\n\n\nquantile(var, design, p; kwargs...)\n\nEstimate quantiles of a list of variables.\n\njulia> quantile(:enroll, srs, [0.1,0.2,0.5,0.75,0.95])\n5×2 DataFrame\n Row │ percentile  statistic\n     │ String      Float64\n─────┼───────────────────────\n   1 │ 0.1             245.5\n   2 │ 0.2             317.6\n   3 │ 0.5             453.0\n   4 │ 0.75            668.5\n   5 │ 0.95           1473.1\n\n\n\n\n\nUse replicate weights to compute the standard errors of the estimated quantiles. \n\njulia> quantile(:enroll, srs_boot, [0.1,0.2,0.5,0.75,0.95])\n5×3 DataFrame\n Row │ percentile  statistic  SE       \n     │ String      Float64    Float64  \n─────┼─────────────────────────────────\n   1 │ 0.1             245.5   20.2964\n   2 │ 0.2             317.6   13.5435\n   3 │ 0.5             453.0   24.9719\n   4 │ 0.75            668.5   34.2487\n   5 │ 0.95           1473.1  142.568\n\n\n\n\n\n","category":"function"},{"location":"api/#Survey.ratio","page":"API reference","title":"Survey.ratio","text":"ratio(numerator, denominator, design)\n\nEstimate the ratio of the columns specified in numerator and denominator.\n\njulia> apiclus1 = load_data(\"apiclus1\");\n\njulia> clus_one_stage = SurveyDesign(apiclus1; clusters = :dnum, weights = :pw);\n\njulia> ratio(:api00, :enroll, clus_one_stage)\n1×1 DataFrame\n Row │ ratio\n     │ Float64\n─────┼─────────\n   1 │ 1.17182\n\n\n\n\n\n\nUse replicate weights to compute the standard error of the ratio.\n\njulia> ratio(:api00, :enroll, clus_one_stage)\n1×1 DataFrame\n Row │ ratio\n     │ Float64\n─────┼─────────\n   1 │ 1.17182\n\n\n\n\n\n\n","category":"function"},{"location":"api/#Survey.plot","page":"API reference","title":"Survey.plot","text":"plot(design, x, y; kwargs...)\n\nScatter plot of survey design variables x and y.\n\nThe plot takes into account the frequency weights specified by the user in the design.\n\njulia> using AlgebraOfGraphics\n\njulia> apisrs = load_data(\"apisrs\");\n\njulia> srs = SurveyDesign(apisrs; weights=:pw);\n\njulia> s = plot(srs, :api99, :api00);\n\njulia> save(\"scatter.png\", s)\n\n(Image: )\n\n\n\n\n\n","category":"function"},{"location":"api/#Survey.boxplot","page":"API reference","title":"Survey.boxplot","text":"boxplot(design, x, y; kwargs...)\n\nBox plot of survey design variable y grouped by column x.\n\nWeights can be specified by a Symbol using the keyword argument weights.\n\nThe keyword arguments are all the arguments that can be passed to mapping in AlgebraOfGraphics.\n\njulia> using AlgebraOfGraphics\n\njulia> apisrs = load_data(\"apisrs\");\n\njulia> srs = SurveyDesign(apisrs; weights=:pw);\n\njulia> bp = boxplot(srs, :stype, :enroll; weights = :pw);\n\njulia> save(\"boxplot.png\", bp)\n\n(Image: )\n\n\n\n\n\n","category":"function"},{"location":"api/#Survey.hist","page":"API reference","title":"Survey.hist","text":"hist(design, var, bins = freedman_diaconis; normalization = :density, kwargs...)\n\nHistogram plot of a survey design variable given by var.\n\nbins can be an Integer specifying the number of equal-width bins, an AbstractVector specifying the bins intervals, or a Function specifying the function used for calculating the number of bins. The possible functions are sturges and freedman_diaconis.\n\nThe normalization can be set to :none, :density, :probability or :pdf. See AlgebraOfGraphics.histogram for more information.\n\nFor the complete argument list see Makie.hist.\n\nnote: Note\nThe weights argument should be a Symbol specifying a design variable.\n\njulia> using AlgebraOfGraphics\n\njulia> apisrs = load_data(\"apisrs\");\n\njulia> srs = SurveyDesign(apisrs; weights=:pw);\n\njulia> h = hist(srs, :enroll);\n\njulia> save(\"hist.png\", h)\n\n(Image: )\n\n\n\n\n\n","category":"function"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The Survey.jl package is not yet registered. For now, installation of the package is done using the following command:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"]  add \"https://github.com/xKDR/Survey.jl.git\"","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"After registration, the regular Pkg commands can be used for installing the package:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Pkg\n\nPkg.add(\"Survey\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"]  add Survey","category":"page"},{"location":"getting_started/#Tutorial","page":"Getting Started","title":"Tutorial","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This tutorial assumes basic knowledge of statistics and survey analysis.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To begin this tutorial, load the package in your workspace:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Survey","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Now load a survey dataset that you want to study. In this tutorial we will be using the Academic Performance Index (API) datasets for Californian schools. The datasets contain information for all schools with at least 100 students and for various probability samples of the data.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"note: Note\nThe API program has been discontinued at the end of 2018. Information is archived here.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"apisrs = load_data(\"apisrs\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"apisrs is a simple random sample of the Academic Performance Index of Californian schools. The load_data function loads it as a DataFrame. You can look at the column names of apisrs to get an idea of what the dataset contains.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"names(apisrs)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Next, build a survey design from your DataFrame:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"srs = SurveyDesign(apisrs; weights=:pw)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This is a simple random sample design with weights given by the column :pw of apisrs. You can also create more complex designs such as stratified or cluster sample designs. You can find more information on the complete capabilities of the package in the Manual. The purpose of this tutorial is to show the basic usage of the package. For that, we will stick with a simple random sample.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Now you can analyse your design according to your needs using the functionality provided by the package. For example, you can compute the estimated mean or population total for a given variable. Let's say you want to find the mean Academic Performance Index from the year 1999. If you are only interested in the estimated mean, then you can directly pass your design to the mean function:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"mean(:api99, srs)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"If you also want to know the standard error of the mean, you need to convert the SurveyDesign to a ReplicateDesign using bootstrapping:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"bsrs = bootweights(srs; replicates = 1000)\nmean(:api99, bsrs)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"You can find the mean of both the 1999 API and 2000 API for a clear comparison between students' performance from one year to another:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"mean([:api99, :api00], bsrs)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The ratio is also appropriate for studying the relationship between the two APIs:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"ratio(:api00, :api99, bsrs)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"If you're interested in a certain statistic estimated by a specific domain, you can add the domain as the second parameter to your function. Let's say you want to find the estimated total number of students enrolled in schools from each county:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"total(:enroll, :cname, bsrs)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Another way to visualize data is through graphs. You can make a histogram to better see the distribution of enrolled students:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# !!!THIS NEEDS TO MATCH THE EXAMPLE IN THE DOCSTRING OF `hist`","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> hist(srs, :enroll)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The REPL doesn't show the plot. To see it, you need to save it locally.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> import AlgebraOfGraphics.save\n\njulia> save(\"hist.png\", h)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"man/comparisons/#Comparison-with-other-survey-analysis-tools","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"There are multiple alternatives that offer survey analysis tools, most notably SAS, Stata and R.","category":"page"},{"location":"man/comparisons/#R-comparison","page":"Comparison with other survey analysis tools","title":"R comparison","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"The inspiration for Survey.jl comes from R. Hence the syntax is in most cases very similar to the syntax in the survey package from R. To showcase this we will use the api datasets found in both R's survey and Survey.jl. See the Tutorial section for more details about the api datesets.","category":"page"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"All examples show the R code first, followed by the Julia code.","category":"page"},{"location":"man/comparisons/#Loading-data","page":"Comparison with other survey analysis tools","title":"Loading data","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"> data(api)\n# all `api` datasets are loaded globally","category":"page"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"julia> srs = load_data(\"apisrs\")\n# only one dataset is loaded and stored in a variable","category":"page"},{"location":"man/comparisons/#Creating-a-design","page":"Comparison with other survey analysis tools","title":"Creating a design","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"> srs = svydesign(id=~1, data=apisrs, weights=~pw) # simple random sample\n> strat = svydesign(id=~1, data=apistrat, strata=~stype, weights=~pw) # stratified\n> clus1 = svydesign(id=~dnum, data=apiclus1, weights=~pw) # clustered (one stage)","category":"page"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"julia> srs = SurveyDesign(apisrs; weights=:pw) # simple random sample\njulia> strat = SurveyDesign(apistrat; strata=:stype, weights=:pw) # stratified\njulia> clus1 = SurveyDesign(apiclus1; clusters=:dnum, weights=:pw) # clustered (one stage)","category":"page"},{"location":"man/comparisons/#Creating-a-replicate-design","page":"Comparison with other survey analysis tools","title":"Creating a replicate design","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"> bsrs = as.svrepdesign(srs, type=\"subbootstrap\")","category":"page"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"julia> bsrs = bootweights(srs)","category":"page"},{"location":"man/comparisons/#Computing-the-estimated-mean","page":"Comparison with other survey analysis tools","title":"Computing the estimated mean","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"> svymean(~api00, bsrs)\n> svymean(~api99+~api00, bsrs)","category":"page"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"julia> mean(:api00, bsrs)\njulia> mean([:api99, :api00], bsrs)","category":"page"},{"location":"man/comparisons/#Computing-the-estimated-total","page":"Comparison with other survey analysis tools","title":"Computing the estimated total","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"> svytotal(~api00, bsrs)\n> svytotal(~api99+~api00, bsrs)","category":"page"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"julia> total(:api00, bsrs)\njulia> total([:api99, :api00], bsrs)","category":"page"},{"location":"man/comparisons/#Computing-quantiles","page":"Comparison with other survey analysis tools","title":"Computing quantiles","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"> svyquantile(~api00, bsrs, 0.5)\n> svyquantile(~api00, bsrs, c(0.25, 0.5, 0.75))","category":"page"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"julia> quantile(:api00, bsrs, 0.5)\njulia> quantile(:api00, bsrs, [0.25, 0.5, 0.75])","category":"page"},{"location":"man/comparisons/#Domain-estimation","page":"Comparison with other survey analysis tools","title":"Domain estimation","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"> svyby(~api00, ~cname, bsrs, svymean)","category":"page"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"julia> mean(:api00, :cname, bsrs)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Survey","category":"page"},{"location":"#Survey","page":"Home","title":"Survey","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is used to study complex survey data. It aims to provide a very efficient computing framework for survey analysis, and be a faster alternative to the survey package ecosystem in R developed by Prof Thomas Lumley[lumley].","category":"page"},{"location":"","page":"Home","title":"Home","text":"Surveys are a standard tool for empirical research in social and behavioural sciences, and also widely used by governments and businesses alike. In order to get a better representation or more precise estimates, complex surveys use sophisticated sampling techniques like clustering, stratification, unequal probability selection or a combination of these. Computing population estimates from a survey is not as simple as mean(x), and requires several corrections, weights calibrations and adjustments, wherein stems the need for a \"survey\" package which automatically applies these mathematical techniques. Size of survey datasets has been slowly increasing over the past few decades with advances in computing power and storage, as well as ease of administering surveys online over longer distances and wider geographic areas. The rapidly growing sizes of survey datasets requires an efficient computing system. ","category":"page"},{"location":"#Highlights","page":"Home","title":"Highlights","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Current feature highlights include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Data structures for survey manipulation and analysis, based on the fantastic DataFrames.jl API.\nSummary statistics such as mean, total, ratio and quantile for whole of sample as well as subpopulations/domains.\nVariance estimation using replicate weighting techniques (current default Rao-Wu bootstrap)\nSingle stage approximation of multistage sampling schemes\nCommon graphical analysis functions using AlgebraOfGraphics backend\nInspired by the familiar R survey and related package interface in the R ecosystem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Other highlights include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Easily enhancible to other replicate methods\nActively developed and maintained\nSubstatially faster than R survey for same functionalities (benchmarking article in the works)\nPromoting code reuse by using widely used and tested DataFrame as the backbone.","category":"page"},{"location":"#Why-a-package-for-survey-analysis-in-Julia?","page":"Home","title":"Why a package for survey analysis in Julia?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Performance with expressivity: Julia is able to combine the expressivity of R/Python with the speed of a systems programming language, so it is ideally placed to be the foundation for a survey analysis framework. \nSeveral software tools are available to analyse complex surveys[list_packages]. The R survey package is a widely used open-source option, but it excels in expressivity, and performance was not a key development goal. Performance is one of the key reasons why many applied survey researchers pay for proprietary SAS/Stata solutions. The authors of this package have waited hours/days in R generating summary statistics (especially standard errors) on really large surveys[stackexchangepost]. \nInitial prototyping in Julia suggested vast speedups for similar analyses vs R[julicon_clip]. In particular, we found magnitude of times speedups when using replicate weighting techniques such as bootstrapping for variance estimation[faster]. In many classes of simulation problems, Julia has a substantial edge over R.\nCommunity interest: There has been interest in a package for survey analysis in the Julia community for quite some time[2], and several attempts to create a package, which never materialised[3]. In the course of development of the pacakage, we received some feedback and even contributing PRs on the project[community].\nDevelopment and maintenance Julia avoids the two language problem, whereas \"fast\" frameworks in R or Python usually rely on behind the scenes calls to C/C++/Fortran for speedups, as native interpreted code in those languages is usually slow. While there are addon packages and methods to boost speed[bschneider], they require high-order programming skills in other \"lower level\" languages. Applied survey researchers just want something that works great out of the box, so a completely Julia-native survey analysis package is great for users as well as long term development and maintenance.\nStatistical ecosystem: The statistical and data ecosytem of Julia has matured to have substantial statistical computing abilities. DataFrames provides the excellent data wrangling and \"split-apply-combine\" style analytics widely used survey analysis workflows[^dataframes.jl]. Makie provides a tightly integrated visualisation backend for graphical analysis of surveys[makie]. LinearAlgebra and Optim as well as auto-differentiation libraries provide cutting edge foundations for further statistical modelling and analysis. Turing and Flux round up the capabilities in bayesian probabilistic programming and deep learning. Building on top of the statistical stack in Julia, Survey is complement to and complemented by the entire data ecosystem.","category":"page"},{"location":"#Plans","page":"Home","title":"Plans","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We plan for efficient implementations of all the methods in R survey. Features for future releases will include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Variance by Taylor linearization for SurveyDesign\nSupport additional replicate weighting algorithms (BRR, Jackknife, other bootstrap flavours) for ReplicateDesign\nSupport for more complex survey designs\nPost-stratification, raking or calibration, GREG estimation and related methods.\nCode analysis and optimisation\nContingency table analysis, support for CategoricalArrays\nIntegration with CRRao.jl for regressions, with design based standard errors. \nIntegration with GLM.jl\nSupport and speedups with CategoricalsArrays\nAssociation and likelihood ratio tests\nSupport for imputing missing data\nBayesian surveys","category":"page"},{"location":"","page":"Home","title":"Home","text":"[makie]: Makie project","category":"page"},{"location":"","page":"Home","title":"Home","text":"[^dataframes.jl]: DataFrames.jl documentation [R_survey]: R survey package [lumley]: Thomas Lumley Homepage [julicon_clip]: Survey.jl clip from Julia Statistics Symposium, JuliaCon 2022 [community]: discussion on discourse posts in August and April 2022. [faster]: benchmarking article in the works [stackexchangepost]: stack exchange discussion of other people with similar stories. [bschneider]: Ben Schneider blog post on how to use RCpp to make survey faster [2]: Julia Discourse posts here and here  [3]: samplics/survey.jl and jamanrique/SurveyAnalysis.jl. [list_packages]: Alan Zaslavsky keeps a comprehensive list of survey analysis software for the ASA Section on Survey Research Methods.","category":"page"},{"location":"man/dataframes/#manual","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"","category":"section"},{"location":"man/dataframes/","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"The internal structure of a survey design is build upon DataFrames. In fact, the data argument is the only required argument for the constructor and it must be an AbstractDataFrame.","category":"page"},{"location":"man/dataframes/#Data-manipulation","page":"DataFrames in Survey","title":"Data manipulation","text":"","category":"section"},{"location":"man/dataframes/","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"The provided DataFrame is altered by the SurveyDesign constructor in order to add columns for frequency and probability weights, sample and population sizes and, if necessary, strata and cluster information.","category":"page"},{"location":"man/dataframes/","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"Notice the change in apisrs:","category":"page"},{"location":"man/dataframes/","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"using Survey","category":"page"},{"location":"man/dataframes/","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"apisrs = load_data(\"apisrs\")\nnames(apisrs)\nsrs = SurveyDesign(apisrs; weights=:pw);\napisrs\nnames(apisrs)","category":"page"},{"location":"man/dataframes/","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"Five columns were added:","category":"page"},{"location":"man/dataframes/","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"false_strata - only in the case of no stratification\nThis column is necessary because when making a ReplicateDesign, the bootweights function uses groupby with a column representing the stratification variable. If there are no strata, there is no such column so it should be added in order to keep bootweights general.\nfalse_cluster - only in the case of no clustering\nThe reasoning is the same as in the case of no stratification.\n_sampsize - sample sizes\n_popsize - population sizes\nThese match the stratification variable:","category":"page"},{"location":"man/dataframes/","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"apistrat = load_data(\"apistrat\");\nstrat = SurveyDesign(apistrat; strata=:stype, weights=:pw);\napistrat[:, [:stype, :_sampsize, :_popsize]]","category":"page"},{"location":"man/dataframes/","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"_allprobs - probability weights","category":"page"},{"location":"man/dataframes/","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"No column was added for frequency weights because the column passed through the weights argument is used by other functions, hence there is no need to add a new column. If weights is not specified, then a column called _weights is added.","category":"page"},{"location":"man/dataframes/#Why-DataFrames","page":"DataFrames in Survey","title":"Why DataFrames","text":"","category":"section"},{"location":"man/dataframes/","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"Survey data most of the time, if not always, is structured in a way that is very well suited for data frames. The DataFrames.jl package is mature and well maintained and provides a lot of functionality that proves useful for using inside functions such as bootweights or mean. Mainly, the functions used are groupby and combine.","category":"page"}]
}
