var documenterSearchIndex = {"docs":
[{"location":"man/plotting/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"Survey uses AlgebraOfGraphics for plotting. All plotting functions support a variable number of keyword arguments (through kwargs...) that are passed internally to corresponding AlgebraOfGraphics functions. See the source code for details: plot, hist, boxplot. This means that all functionality provided by AlgebraOfGraphics is supported in Survey.","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"Specific functionality might need to be imported from AlgebraOfGraphics. Moreover, in order to choose the preferred Makie backend you must explicitly use it:","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"using AlgebraOfGraphics, CairoMakie","category":"page"},{"location":"man/replicate/#Replicate-weights","page":"Replicate weights","title":"Replicate weights","text":"","category":"section"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"Replicate weights are a method for estimating the standard errors of survey statistics in complex sample designs.","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"The basic idea behind replicate weights is to create multiple versions of the original sample weights, each with small, randomly generated perturbations. The multiple versions of the sample weights are then used to calculate the survey statistic of interest, such as the mean or total, on multiple replicate samples. The variance of the survey statistic is then estimated by computing the variance across the replicate samples.","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"Currently, the Rao-Wu bootstrap[1] and the Jackknife [2] are the only methods in the package for generating replicate weights. In the future, the package will support additional types of inference methods, which will be passed when creating a ReplicateDesign object.","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"The bootweights function of the package can be used to generate a ReplicateDesign using the Rao-Wu bootstrap method from a SurveyDesign. For example: ","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"using Survey\napistrat = load_data(\"apistrat\")\ndstrat = SurveyDesign(apistrat; strata=:stype, weights=:pw)\nbstrat = bootweights(dstrat; replicates = 10)","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"The jackknifeweights function of the package can be used to generate a ReplicateDesign using the Jackknife method from a SurveyDesign. For example: ","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"using Survey\napistrat = load_data(\"apistrat\")\ndstrat = SurveyDesign(apistrat; strata=:stype, weights=:pw)\nbstrat = jackknifeweights(dstrat; replicates = 10)","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"For each replicate, the DataFrame of ReplicateDesign has an additional column. The name of the column is replicate_ followed by the replicate number.  ","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"names(bstrat.data)","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"replicate_1, replicate_2, replicate_3, replicate_4, replicate_5, replicate_6, replicate_7, replicate_8, replicate_9, replicate_10, are the replicate weight columns. ","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"While a SurveyDesign can be used to estimate a statistics. For example: ","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"mean(:api00, dstrat)","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"The ReplicateDesign can be used to compute the standard error of the statistic. For example: ","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"mean(:api00, bstrat)","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"For each replicate weight, the statistic is calculated using it instead of the weight. The standard deviation of those statistics is the standard error of the estimate.  ","category":"page"},{"location":"man/replicate/#References","page":"Replicate weights","title":"References","text":"","category":"section"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"[1]: Rust, Keith F., and J. N. K. Rao. \"Variance estimation for complex surveys using replication techniques.\" Statistical methods in medical research 5.3 (1996): 283-310.","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"[2]: Miller, Rupert G. “The Jackknife–A Review.” Biometrika 61, no. 1 (1974): 1–15. https://doi.org/10.2307/2334280.","category":"page"},{"location":"api/#API","page":"API reference","title":"API","text":"","category":"section"},{"location":"api/#Index","page":"API reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Module = [Survey]\nOrder = [:type, :function]\nPrivate = false","category":"page"},{"location":"api/","page":"API reference","title":"API reference","text":"AbstractSurveyDesign\nSurveyDesign\nReplicateDesign\nBootstrapReplicates\nJackknifeReplicates\nload_data\nbootweights\njackknifeweights\nSurvey.standarderror\nmean\ntotal\nquantile\nratio\nglm\nplot\nboxplot\nhist\nSurvey.sturges\nSurvey.freedman_diaconis","category":"page"},{"location":"api/#Survey.AbstractSurveyDesign","page":"API reference","title":"Survey.AbstractSurveyDesign","text":"AbstractSurveyDesign\n\nSupertype for every survey design type. \n\nnote: Note\nThe data passed to a survey constructor is modified. To avoid this pass a copy of the data instead of the original.\n\n\n\n\n\n","category":"type"},{"location":"api/#Survey.SurveyDesign","page":"API reference","title":"Survey.SurveyDesign","text":"SurveyDesign <: AbstractSurveyDesign\n\nGeneral survey design encompassing a simple random, stratified, cluster or multi-stage design.\n\nIn the case of cluster sample, the clusters are chosen by simple random sampling. All individuals in one cluster are sampled. The clusters are considered disjoint and nested.\n\nstrata and clusters must be given as columns in data.\n\nArguments:\n\ndata::AbstractDataFrame: the survey dataset (!this gets modified by the constructor).\nstrata::Union{Nothing, Symbol}=nothing: the stratification variable.\nclusters::Union{Nothing, Symbol, Vector{Symbol}}=nothing: the clustering variable.\nweights::Union{Nothing, Symbol}=nothing: the sampling weights.\npopsize::Union{Nothing, Symbol}=nothing: the (expected) survey population size.\n\njulia> apiclus1 = load_data(\"apiclus1\");\n\njulia> dclus1 = SurveyDesign(apiclus1; clusters=:dnum, weights=:pw)\nSurveyDesign:\ndata: 183×44 DataFrame\nstrata: none\ncluster: dnum\n    [637, 637, 637  …  448]\npopsize: [507.7049, 507.7049, 507.7049  …  507.7049]\nsampsize: [15, 15, 15  …  15]\nweights: [33.847, 33.847, 33.847  …  33.847]\nallprobs: [0.0295, 0.0295, 0.0295  …  0.0295]\n\n\n\n\n\n","category":"type"},{"location":"api/#Survey.ReplicateDesign","page":"API reference","title":"Survey.ReplicateDesign","text":"ReplicateDesign <: AbstractSurveyDesign\n\nSurvey design obtained by replicating an original design using an inference method like bootweights or jackknifeweights. If replicate weights are available, then they can be used to directly create a ReplicateDesign object.\n\nConstructors\n\nReplicateDesign{ReplicateType}(\n    data::AbstractDataFrame,\n    replicate_weights::Vector{Symbol};\n    clusters::Union{Nothing,Symbol,Vector{Symbol}} = nothing,\n    strata::Union{Nothing,Symbol} = nothing,\n    popsize::Union{Nothing,Symbol} = nothing,\n    weights::Union{Nothing,Symbol} = nothing\n) where {ReplicateType <: InferenceMethod}\n\nReplicateDesign{ReplicateType}(\n    data::AbstractDataFrame,\n    replicate_weights::UnitIndex{Int};\n    clusters::Union{Nothing,Symbol,Vector{Symbol}} = nothing,\n    strata::Union{Nothing,Symbol} = nothing,\n    popsize::Union{Nothing,Symbol} = nothing,\n    weights::Union{Nothing,Symbol} = nothing\n) where {ReplicateType <: InferenceMethod}\n\nReplicateDesign{ReplicateType}(\n    data::AbstractDataFrame,\n    replicate_weights::Regex;\n    clusters::Union{Nothing,Symbol,Vector{Symbol}} = nothing,\n    strata::Union{Nothing,Symbol} = nothing,\n    popsize::Union{Nothing,Symbol} = nothing,\n    weights::Union{Nothing,Symbol} = nothing\n) where {ReplicateType <: InferenceMethod}\n\nArguments\n\nReplicateType must be one of the supported inference types; currently the package supports BootstrapReplicates and JackknifeReplicates. The constructor has the same arguments as SurveyDesign. The only additional argument is replicate_weights, which can be of one of the following types.\n\nVector{Symbol}: In this case, each Symbol in the vector should represent a column of data containing the replicate weights.\nUnitIndex{Int}: For instance, this could be UnitRange(5:10). This will mean that the replicate weights are contained in columns 5 through 10.\nRegex: In this case, all the columns of data which match this Regex will be treated as the columns containing the replicate weights.\n\nAll the columns containing the replicate weights will be renamed to the form replicate_i, where i ranges from 1 to the number of columns containing the replicate weights.\n\nExamples\n\nHere is an example where the bootweights function is used to create a ReplicateDesign{BootstrapReplicates}.\n\njulia> apistrat = load_data(\"apistrat\");\n\njulia> dstrat = SurveyDesign(apistrat; strata=:stype, weights=:pw);\n\njulia> bootstrat = bootweights(dstrat; replicates=1000)     # creating a ReplicateDesign using bootweights\nReplicateDesign{BootstrapReplicates}:\ndata: 200×1044 DataFrame\nstrata: stype\n    [E, E, E  …  H]\ncluster: none\npopsize: [4420.9999, 4420.9999, 4420.9999  …  755.0]\nsampsize: [100, 100, 100  …  50]\nweights: [44.21, 44.21, 44.21  …  15.1]\nallprobs: [0.0226, 0.0226, 0.0226  …  0.0662]\ntype: bootstrap\nreplicates: 1000\n\n\nIf the replicate weights are given to us already, then we can directly pass them to the ReplicateDesign constructor. For instance, in the above example, suppose we had the bootstrat data as a CSV file (for this example, we also rename the columns containing the replicate weights to the form r_i).\n\njulia> using CSV;\n\njulia> DataFrames.rename!(bootstrat.data, [\"replicate_\"*string(index) => \"r_\"*string(index) for index in 1:1000]);\n\njulia> CSV.write(\"apistrat_withreplicates.csv\", bootstrat.data);\n\n\nWe can now pass the replicate weights directly to the ReplicateDesign constructor, either as a Vector{Symbol}, a UnitRange or a Regex.\n\njulia> bootstrat_direct = ReplicateDesign{BootstrapReplicates}(CSV.read(\"apistrat_withreplicates.csv\", DataFrame), [Symbol(\"r_\"*string(replicate)) for replicate in 1:1000]; strata=:stype, weights=:pw)\nReplicateDesign{BootstrapReplicates}:\ndata: 200×1044 DataFrame\nstrata: stype\n    [E, E, E  …  H]\ncluster: none\npopsize: [4420.9999, 4420.9999, 4420.9999  …  755.0]\nsampsize: [100, 100, 100  …  50]\nweights: [44.21, 44.21, 44.21  …  15.1]\nallprobs: [0.0226, 0.0226, 0.0226  …  0.0662]\ntype: bootstrap\nreplicates: 1000\n\njulia> bootstrat_unitrange = ReplicateDesign{BootstrapReplicates}(CSV.read(\"apistrat_withreplicates.csv\", DataFrame), UnitRange(45:1044);strata=:stype, weights=:pw)\nReplicateDesign{BootstrapReplicates}:\ndata: 200×1044 DataFrame\nstrata: stype\n    [E, E, E  …  H]\ncluster: none\npopsize: [4420.9999, 4420.9999, 4420.9999  …  755.0]\nsampsize: [100, 100, 100  …  50]\nweights: [44.21, 44.21, 44.21  …  15.1]\nallprobs: [0.0226, 0.0226, 0.0226  …  0.0662]\ntype: bootstrap\nreplicates: 1000\n\njulia> bootstrat_regex = ReplicateDesign{BootstrapReplicates}(CSV.read(\"apistrat_withreplicates.csv\", DataFrame), r\"r_\\d\";strata=:stype, weights=:pw)\nReplicateDesign{BootstrapReplicates}:\ndata: 200×1044 DataFrame\nstrata: stype\n    [E, E, E  …  H]\ncluster: none\npopsize: [4420.9999, 4420.9999, 4420.9999  …  755.0]\nsampsize: [100, 100, 100  …  50]\nweights: [44.21, 44.21, 44.21  …  15.1]\nallprobs: [0.0226, 0.0226, 0.0226  …  0.0662]\ntype: bootstrap\nreplicates: 1000\n\n\n\n\n\n\n","category":"type"},{"location":"api/#Survey.BootstrapReplicates","page":"API reference","title":"Survey.BootstrapReplicates","text":"BootstrapReplicates <: InferenceMethod\n\nType for the bootstrap replicates method. For more details, see bootweights.\n\n\n\n\n\n","category":"type"},{"location":"api/#Survey.JackknifeReplicates","page":"API reference","title":"Survey.JackknifeReplicates","text":"JackknifeReplicates <: InferenceMethod\n\nType for the Jackknife replicates method. For more details, see jackknifeweights.\n\n\n\n\n\n","category":"type"},{"location":"api/#Survey.load_data","page":"API reference","title":"Survey.load_data","text":"load_data(name)\n\nLoad a sample dataset as a DataFrame.\n\nAll available datasets can be found here.\n\njulia> apisrs = load_data(\"apisrs\")\n200×40 DataFrame\n Row │ Column1  cds             stype    name             sname                ⋯\n     │ Int64    Int64           String1  String15         String               ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │    1039  15739081534155  H        McFarland High   McFarland High       ⋯\n   2 │    1124  19642126066716  E        Stowers (Cecil   Stowers (Cecil B.) E\n   3 │    2868  30664493030640  H        Brea-Olinda Hig  Brea-Olinda High\n   4 │    1273  19644516012744  E        Alameda Element  Alameda Elementary\n   5 │    4926  40688096043293  E        Sunnyside Eleme  Sunnyside Elementary ⋯\n   6 │    2463  19734456014278  E        Los Molinos Ele  Los Molinos Elementa\n   7 │    2031  19647336058200  M        Northridge Midd  Northridge Middle\n   8 │    1736  19647336017271  E        Glassell Park E  Glassell Park Elemen\n  ⋮  │    ⋮           ⋮            ⋮            ⋮                       ⋮      ⋱\n 194 │    4880  39686766042782  E        Tyler Skills El  Tyler Skills Element ⋯\n 195 │     993  15636851531987  H        Desert Junior/S  Desert Junior/Senior\n 196 │     969  15635291534775  H        North High       North High\n 197 │    1752  19647336017446  E        Hammel Street E  Hammel Street Elemen\n 198 │    4480  37683386039143  E        Audubon Element  Audubon Elementary   ⋯\n 199 │    4062  36678196036222  E        Edison Elementa  Edison Elementary\n 200 │    2683  24657716025621  E        Franklin Elemen  Franklin Elementary\n                                                 36 columns and 185 rows omitted\n\n\n\n\n\n","category":"function"},{"location":"api/#Survey.bootweights","page":"API reference","title":"Survey.bootweights","text":"Use bootweights to create replicate weights using Rao-Wu bootstrap. The function accepts a SurveyDesign and returns a ReplicateDesign{BootstrapReplicates} which has additional columns for replicate weights.  \n\nThe replicate weight for replicate r is computed using the formula w_i(r) = w_i times fracn_hn_h - 1 m_hj(r) for observation i in psu j of stratum h. \n\nIn the formula above, w_i is the original weight for observation i, n_h is the number of psus in stratum h, and m_hj(r) is the number of psus in stratum h that are selected in replicate r.\n\njulia> using Random\n\njulia> apiclus1 = load_data(\"apiclus1\");\n\njulia> dclus1 = SurveyDesign(apiclus1; clusters = :dnum, popsize=:fpc);\n\njulia> bootweights(dclus1; replicates=1000, rng=MersenneTwister(111)) # choose a seed for deterministic results\nReplicateDesign{BootstrapReplicates}:\ndata: 183×1044 DataFrame\nstrata: none\ncluster: dnum\n    [61, 61, 61  …  815]\npopsize: [757, 757, 757  …  757]\nsampsize: [15, 15, 15  …  15]\nweights: [50.4667, 50.4667, 50.4667  …  50.4667]\nallprobs: [0.0198, 0.0198, 0.0198  …  0.0198]\ntype: bootstrap\nreplicates: 1000\n\n\nReference\n\npg 385, Section 9.3.3 Bootstrap - Sharon Lohr, Sampling Design and Analysis (2010)\n\n\n\n\n\n","category":"function"},{"location":"api/#Survey.jackknifeweights","page":"API reference","title":"Survey.jackknifeweights","text":"jackknifeweights(design::SurveyDesign)\n\nDelete-1 Jackknife algorithm for replication weights from sampling weights. The replicate weights are calculated using the following formula.\n\nw_i(hj) =\nbegincases\n    w_iquadquad textif observation unit itext is not in stratum h\n    0quadquad textif observation unit itext is in psu jtextof stratum h\n    dfracn_hn_h - 1w_i quadquad textif observation unit itext is in stratum htext but not in psu j\nendcases\n\nIn the above formula, w_i represent the original weights, w_i(hj) represent the replicate weights when the jth PSU from cluster h is removed, and n_h represents the number of unique PSUs within cluster h. Replicate weights are added as columns to design.data, and these columns have names of the form replicate_i, where i ranges from 1 to the number of replicate weight columns.\n\nExamples\n\njulia> using Survey;\n\njulia> apistrat = load_data(\"apistrat\");\n\njulia> dstrat = SurveyDesign(apistrat; strata=:stype, weights=:pw);\n\njulia> rstrat = jackknifeweights(dstrat)\nReplicateDesign{JackknifeReplicates}:\ndata: 200×244 DataFrame\nstrata: stype\n    [E, E, E  …  M]\ncluster: none\npopsize: [4420.9999, 4420.9999, 4420.9999  …  1018.0]\nsampsize: [100, 100, 100  …  50]\nweights: [44.21, 44.21, 44.21  …  20.36]\nallprobs: [0.0226, 0.0226, 0.0226  …  0.0491]\ntype: jackknife\nreplicates: 200\n\n\nReference\n\npg 380-382, Section 9.3.2 Jackknife - Sharon Lohr, Sampling Design and Analysis (2010)\n\n\n\n\n\n","category":"function"},{"location":"api/#Survey.standarderror","page":"API reference","title":"Survey.standarderror","text":"standarderror(x::Union{Symbol, Vector{Symbol}}, func::Function, design::ReplicateDesign{BootstrapReplicates}, args...; kwargs...)\n\nCompute the standard error of the estimated mean using the bootstrap method.\n\nArguments\n\nx::Union{Symbol, Vector{Symbol}}: Symbol or vector of symbols representing the variable(s) for which the mean is estimated.\nfunc::Function: Function used to calculate the mean.\ndesign::ReplicateDesign{BootstrapReplicates}: Replicate design object.\nargs...: Additional arguments to be passed to the function.\nkwargs...: Additional keyword arguments.\n\nReturns\n\ndf: DataFrame containing the estimated mean and its standard error.\n\nThe standard error is calculated using the formula\n\nhatV(hattheta) = dfrac1Rsum_i = 1^R(theta_i - hattheta)^2\n\nwhere above R is the number of replicate weights, theta_i is the estimator computed using the ith set of replicate weights, and hattheta is the estimator computed using the original weights.\n\nExamples\n\njulia> my_mean(df::DataFrame, column, weights) = StatsBase.mean(df[!, column], StatsBase.weights(df[!, weights]));\n\njulia> Survey.standarderror(:api00, my_mean, bclus1)\n1×2 DataFrame\n Row │ estimator  SE\n     │ Float64    Float64\n─────┼────────────────────\n   1 │   644.169  23.4107\n\n\n\n\n\nstandarderror(x::Symbol, func::Function, design::ReplicateDesign{JackknifeReplicates})\n\nCompute standard error of column x for the given func using the Jackknife method. The formula to compute this variance is the following.\n\nhatV_textJK(hattheta) = sum_h = 1^H dfracn_h - 1n_hsum_j = 1^n_h(hattheta_(hj) - hattheta)^2\n\nAbove, hattheta represents the estimator computed using the original weights, and hattheta_(hj) represents the estimator computed from the replicate weights obtained when PSU j from cluster h is removed.\n\nExamples\n\njulia> my_mean(df::DataFrame, column, weights) = StatsBase.mean(df[!, column], StatsBase.weights(df[!, weights]));\n\njulia> Survey.standarderror(:api00, my_mean, rstrat)\n1×2 DataFrame\n Row │ estimator  SE\n     │ Float64    Float64\n─────┼────────────────────\n   1 │   662.287  9.53613\n\nReference\n\npg 380-382, Section 9.3.2 Jackknife - Sharon Lohr, Sampling Design and Analysis (2010)\n\n\n\n\n\n","category":"function"},{"location":"api/#Statistics.mean","page":"API reference","title":"Statistics.mean","text":"mean(var, design)\n\nEstimate the mean of a variable.\n\njulia> apiclus1 = load_data(\"apiclus1\");\n\njulia> dclus1 = SurveyDesign(apiclus1; clusters = :dnum, weights = :pw)\nSurveyDesign:\ndata: 183×44 DataFrame\nstrata: none\ncluster: dnum\n    [637, 637, 637  …  448]\npopsize: [507.7049, 507.7049, 507.7049  …  507.7049]\nsampsize: [15, 15, 15  …  15]\nweights: [33.847, 33.847, 33.847  …  33.847]\nallprobs: [0.0295, 0.0295, 0.0295  …  0.0295]\n\njulia> mean(:api00, dclus1)\n1×1 DataFrame\n Row │ mean\n     │ Float64\n─────┼─────────\n   1 │ 644.169 \n\n\n\n\n\nmean(x::Symbol, design::ReplicateDesign)\n\nCompute the standard error of the estimated mean using replicate weights.\n\nArguments\n\nx::Symbol: Symbol representing the variable for which the mean is estimated.\ndesign::ReplicateDesign: Replicate design object.\n\nReturns\n\ndf: DataFrame containing the estimated mean and its standard error.\n\nExamples\n\njulia> mean(:api00, bclus1)\n1×2 DataFrame\n Row │ mean     SE\n     │ Float64  Float64\n─────┼──────────────────\n   1 │ 644.169  23.4107\n\n\n\n\n\nEstimate the mean of a list of variables.\n\njulia> mean([:api00, :enroll], dclus1)\n2×2 DataFrame\n Row │ names   mean\n     │ String  Float64\n─────┼─────────────────\n   1 │ api00   644.169\n   2 │ enroll  549.716\n\nUse replicate weights to compute the standard error of the estimated means. \n\njulia> mean([:api00, :enroll], bclus1)\n2×3 DataFrame\n Row │ names   mean     SE\n     │ String  Float64  Float64\n─────┼──────────────────────────\n   1 │ api00   644.169  23.4107\n   2 │ enroll  549.716  45.7835 \n\n\n\n\n\nmean(var, domain, design)\n\nEstimate means of domains.\n\njulia> mean(:api00, :cname, dclus1)\n11×2 DataFrame\n Row │ mean     cname\n     │ Float64  String\n─────┼──────────────────────\n   1 │ 669.0    Alameda\n   2 │ 472.0    Fresno\n   3 │ 452.5    Kern\n   4 │ 647.267  Los Angeles\n   5 │ 623.25   Mendocino\n   6 │ 519.25   Merced\n   7 │ 710.563  Orange\n   8 │ 709.556  Plumas\n   9 │ 659.436  San Diego\n  10 │ 551.189  San Joaquin\n  11 │ 732.077  Santa Clara\n\nUse the replicate design to compute standard errors of the estimated means. \n\njulia> mean(:api00, :cname, bclus1)\n11×3 DataFrame\n Row │ mean     SE            cname\n     │ Float64  Float64       String\n─────┼────────────────────────────────────\n   1 │ 732.077  58.2169       Santa Clara\n   2 │ 659.436   2.66703      San Diego\n   3 │ 519.25    2.28936e-15  Merced\n   4 │ 647.267  47.6233       Los Angeles\n   5 │ 710.563   2.19826e-13  Orange\n   6 │ 472.0     1.13687e-13  Fresno\n   7 │ 709.556   1.26058e-13  Plumas\n   8 │ 669.0     1.27527e-13  Alameda\n   9 │ 551.189   2.18162e-13  San Joaquin\n  10 │ 452.5     0.0          Kern\n  11 │ 623.25    1.09545e-13  Mendocino\n\n\n\n\n\n","category":"function"},{"location":"api/#Survey.total","page":"API reference","title":"Survey.total","text":"total(var, design)\n\nEstimate the population total of variable.\n\njulia> apiclus1 = load_data(\"apiclus1\");\n\njulia> dclus1 = SurveyDesign(apiclus1; clusters = :dnum, weights = :pw);\n\njulia> total(:api00, dclus1)\n1×1 DataFrame\n Row │ total\n     │ Float64\n─────┼───────────\n   1 │ 3.98999e6\n\n\n\n\n\ntotal(x::Symbol, design::ReplicateDesign)\n\nCompute the standard error of the estimated total using replicate weights.\n\nArguments\n\nx::Symbol: Symbol representing the variable for which the total is estimated.\ndesign::ReplicateDesign: Replicate design object.\n\nReturns\n\ndf: DataFrame containing the estimated total and its standard error.\n\nExamples\n\njulia> total(:api00, bclus1)\n1×2 DataFrame\n Row │ total      SE\n     │ Float64    Float64\n─────┼──────────────────────\n   1 │ 3.98999e6  9.01611e5\n\n\n\n\n\nEstimate the population total of a list of variables.\n\njulia> total([:api00, :enroll], dclus1)\n2×2 DataFrame\n Row │ names   total\n     │ String  Float64\n─────┼───────────────────\n   1 │ api00   3.98999e6\n   2 │ enroll  3.40494e6\n\nUse replicate weights to compute the standard error of the estimated means. \n\njulia> total([:api00, :enroll], bclus1)\n2×3 DataFrame\n Row │ names   total      SE\n     │ String  Float64    Float64\n─────┼──────────────────────────────\n   1 │ api00   3.98999e6  9.01611e5\n   2 │ enroll  3.40494e6  9.33396e5 \n\n\n\n\n\ntotal(var, domain, design)\n\nEstimate population totals of domains.\n\njulia> total(:api00, :cname, dclus1)\n11×2 DataFrame\n Row │ total           cname\n     │ Float64         String\n─────┼─────────────────────────────\n   1 │ 249080.0        Alameda\n   2 │  63903.1        Fresno\n   3 │  30631.5        Kern\n   4 │      3.2862e5   Los Angeles\n   5 │  84380.6        Mendocino\n   6 │  70300.2        Merced\n   7 │      3.84807e5  Orange\n   8 │      2.16147e5  Plumas\n   9 │      1.2276e6   San Diego\n  10 │      6.90276e5  San Joaquin\n  11 │      6.44244e5  Santa Clara\n\nUse the replicate design to compute standard errors of the estimated totals. \n\njulia> total(:api00, :cname, bclus1)\n11×3 DataFrame\n Row │ total           SE             cname\n     │ Float64         Float64        String\n─────┼────────────────────────────────────────────\n   1 │      6.44244e5      4.2273e5   Santa Clara\n   2 │      1.2276e6       8.62727e5  San Diego\n   3 │  70300.2        71336.3        Merced\n   4 │      3.2862e5       2.93936e5  Los Angeles\n   5 │      3.84807e5      3.88014e5  Orange\n   6 │  63903.1        64781.7        Fresno\n   7 │      2.16147e5      2.12089e5  Plumas\n   8 │ 249080.0            2.49228e5  Alameda\n   9 │      6.90276e5      6.81604e5  San Joaquin\n  10 │  30631.5        30870.3        Kern\n  11 │  84380.6        80215.9        Mendocino\n\n\n\n\n\n","category":"function"},{"location":"api/#Statistics.quantile","page":"API reference","title":"Statistics.quantile","text":"quantile(var, design, p; kwargs...)\n\nEstimate quantile of a variable.\n\nHyndman and Fan compiled a taxonomy of nine algorithms to estimate quantiles. These are implemented in Statistics.quantile, which this function calls. Julia, R and Python-numpy use the same defaults\n\nReferences:\n\nHyndman, R.J and Fan, Y. (1996) \"Sample Quantiles in Statistical Packages\", The American Statistician, Vol. 50, No. 4, pp. 361-365.\nQuantiles on wikipedia\nComplex Surveys: a guide to analysis using R, Section 2.4.1 and Appendix C.4.\n\njulia> apisrs = load_data(\"apisrs\");\n\njulia> srs = SurveyDesign(apisrs; weights=:pw); \n\njulia> quantile(:api00, srs, 0.5)\n1×1 DataFrame\n Row │ 0.5th percentile\n     │ Float64\n─────┼──────────────────\n   1 │            659.0\n\n\n\n\n\nquantile(x::Symbol, design::ReplicateDesign, p; kwargs...)\n\nCompute the standard error of the estimated quantile using replicate weights.\n\nArguments\n\nx::Symbol: Symbol representing the variable for which the quantile is estimated.\ndesign::ReplicateDesign: Replicate design object.\np::Real: Quantile value to estimate, ranging from 0 to 1.\nkwargs...: Additional keyword arguments.\n\nReturns\n\ndf: DataFrame containing the estimated quantile and its standard error.\n\nExamples\n\njulia> quantile(:api00, bsrs, 0.5)\n1×2 DataFrame\n Row │ 0.5th percentile  SE\n     │ Float64           Float64\n─────┼───────────────────────────\n   1 │            659.0  14.9764\n\n\n\n\n\nquantile(var, design, p; kwargs...)\n\nEstimate quantiles of a list of variables.\n\njulia> quantile(:enroll, srs, [0.1,0.2,0.5,0.75,0.95])\n5×2 DataFrame\n Row │ percentile  statistic\n     │ String      Float64\n─────┼───────────────────────\n   1 │ 0.1             245.5\n   2 │ 0.2             317.6\n   3 │ 0.5             453.0\n   4 │ 0.75            668.5\n   5 │ 0.95           1473.1\n\n\n\n\n\nUse replicate weights to compute the standard errors of the estimated quantiles. \n\njulia> quantile(:enroll, bsrs, [0.1,0.2,0.5,0.75,0.95])\n5×3 DataFrame\n Row │ percentile  statistic  SE       \n     │ String      Float64    Float64  \n─────┼─────────────────────────────────\n   1 │ 0.1             245.5   20.2964\n   2 │ 0.2             317.6   13.5435\n   3 │ 0.5             453.0   24.9719\n   4 │ 0.75            668.5   34.2487\n   5 │ 0.95           1473.1  142.568\n\n\n\n\n\nquantile(var, domain, design)\n\nEstimate a quantile of domains.\n\njulia> quantile(:api00, :cname, dclus1, 0.5)\n11×2 DataFrame\n Row │ 0.5th percentile  cname\n     │ Float64           String\n─────┼───────────────────────────────\n   1 │            669.0  Alameda\n   2 │            474.5  Fresno\n   3 │            452.5  Kern\n   4 │            628.0  Los Angeles\n   5 │            616.5  Mendocino\n   6 │            519.5  Merced\n   7 │            717.5  Orange\n   8 │            699.0  Plumas\n   9 │            657.0  San Diego\n  10 │            542.0  San Joaquin\n  11 │            718.0  Santa Clara\n\n\n\n\n\n","category":"function"},{"location":"api/#Survey.ratio","page":"API reference","title":"Survey.ratio","text":"ratio(numerator, denominator, design)\n\nEstimate the ratio of the columns specified in numerator and denominator.\n\njulia> apiclus1 = load_data(\"apiclus1\");\n\njulia> dclus1 = SurveyDesign(apiclus1; clusters = :dnum, weights = :pw);\n\njulia> ratio([:api00, :enroll], dclus1)\n1×1 DataFrame\n Row │ ratio\n     │ Float64\n─────┼─────────\n   1 │ 1.17182\n\n\n\n\n\n\nratio(x::Vector{Symbol}, design::ReplicateDesign)\n\nCompute the standard error of the ratio using replicate weights.\n\nArguments\n\nvariable_num::Symbol: Symbol representing the numerator variable.\nvariable_den::Symbol: Symbol representing the denominator variable.\ndesign::ReplicateDesign: Replicate design object.\n\nExamples\n\njulia> ratio([:api00, :api99], bclus1)\n1×2 DataFrame\n Row │ estimator  SE         \n     │ Float64    Float64    \n─────┼───────────────────────\n   1 │   1.06127  0.00672259\n\n\n\n\n\nratio(var, domain, design)\n\nEstimate ratios of domains.\n\njulia> ratio([:api00, :api99], :cname, dclus1)\n11×2 DataFrame\n Row │ ratio    cname\n     │ Float64  String\n─────┼──────────────────────\n   1 │ 1.09852  Alameda\n   2 │ 1.17779  Fresno\n   3 │ 1.11453  Kern\n   4 │ 1.06307  Los Angeles\n   5 │ 1.00565  Mendocino\n   6 │ 1.08121  Merced\n   7 │ 1.03628  Orange\n   8 │ 1.02127  Plumas\n   9 │ 1.06112  San Diego\n  10 │ 1.07331  San Joaquin\n  11 │ 1.05598  Santa Clara\n\nUse the replicate design to compute standard errors of the estimated means. \n\njulia> ratio([:api00, :api99], :cname, bclus1)\n11×3 DataFrame\n Row │ estimator  SE           cname       \n     │ Float64    Float64      String      \n─────┼─────────────────────────────────────\n   1 │   1.05598  0.0189429    Santa Clara\n   2 │   1.06112  0.00979481   San Diego\n   3 │   1.08121  6.85453e-17  Merced\n   4 │   1.06307  0.0257137    Los Angeles\n   5 │   1.03628  0.0          Orange\n   6 │   1.17779  6.27535e-18  Fresno\n   7 │   1.02127  0.0          Plumas\n   8 │   1.09852  2.12683e-16  Alameda\n   9 │   1.07331  2.22045e-16  San Joaquin\n  10 │   1.11453  0.0          Kern\n  11 │   1.00565  0.0          Mendocino\n\n\n\n\n\n","category":"function"},{"location":"api/#GLM.glm","page":"API reference","title":"GLM.glm","text":"glm(formula::FormulaTerm, design::ReplicateDesign, args...; kwargs...)\n\nPerform generalized linear modeling (GLM) using the survey design with replicates.\n\nArguments\n\nformula: A FormulaTerm specifying the model formula.\ndesign: A ReplicateDesign object representing the survey design with replicates.\nargs...: Additional arguments to be passed to the glm function.\nkwargs...: Additional keyword arguments to be passed to the glm function.\n\nReturns\n\nA DataFrame containing the estimates for model coefficients and their standard errors.\n\nExample\n\napisrs = load_data(\"apisrs\")\nsrs = SurveyDesign(apisrs)\nbsrs = bootweights(srs, replicates = 2000)\nresult = glm(@formula(api00 ~ api99), bsrs, Normal())\n\njulia> glm(@formula(api00 ~ api99), bsrs, Normal())\n2×2 DataFrame\n Row │ estimator  SE        \n     │ Float64    Float64   \n─────┼──────────────────────\n   1 │ 63.2831    9.41231\n   2 │  0.949762  0.0135488\n\n\n\n\n\n","category":"function"},{"location":"api/#Survey.plot","page":"API reference","title":"Survey.plot","text":"plot(design, x, y; kwargs...)\n\nScatter plot of survey design variables x and y.\n\nThe plot takes into account the frequency weights specified by the user in the design.\n\njulia> using AlgebraOfGraphics\n\njulia> apisrs = load_data(\"apisrs\");\n\njulia> srs = SurveyDesign(apisrs; weights=:pw);\n\njulia> s = plot(srs, :api99, :api00);\n\njulia> save(\"scatter.png\", s)\n\n(Image: )\n\n\n\n\n\n","category":"function"},{"location":"api/#Survey.boxplot","page":"API reference","title":"Survey.boxplot","text":"boxplot(design, x, y; kwargs...)\n\nBox plot of survey design variable y grouped by column x.\n\nWeights can be specified by a Symbol using the keyword argument weights.\n\nThe keyword arguments are all the arguments that can be passed to mapping in AlgebraOfGraphics.\n\njulia> using AlgebraOfGraphics\n\njulia> apisrs = load_data(\"apisrs\");\n\njulia> srs = SurveyDesign(apisrs; weights=:pw);\n\njulia> bp = boxplot(srs, :stype, :enroll; weights = :pw);\n\njulia> save(\"boxplot.png\", bp)\n\n(Image: )\n\n\n\n\n\n","category":"function"},{"location":"api/#Survey.hist","page":"API reference","title":"Survey.hist","text":"hist(design, var, bins = freedman_diaconis; normalization = :density, kwargs...)\n\nHistogram plot of a survey design variable given by var.\n\nbins can be an Integer specifying the number of equal-width bins, an AbstractVector specifying the bins intervals, or a Function specifying the function used for calculating the number of bins. The possible functions are sturges and freedman_diaconis.\n\nThe normalization can be set to :none, :density, :probability or :pdf. See AlgebraOfGraphics.histogram for more information.\n\nFor the complete argument list see Makie.hist.\n\nnote: Note\nThe weights argument should be a Symbol specifying a design variable.\n\njulia> using AlgebraOfGraphics\n\njulia> apisrs = load_data(\"apisrs\");\n\njulia> srs = SurveyDesign(apisrs; weights=:pw);\n\njulia> h = hist(srs, :enroll);\n\njulia> save(\"hist.png\", h)\n\n(Image: )\n\n\n\n\n\n","category":"function"},{"location":"api/#Survey.sturges","page":"API reference","title":"Survey.sturges","text":"sturges(design::SurveyDesign, var::Symbol)\n\nCalculate the number of bins to use in a histogram using the Sturges rule.\n\nExamples\n\njulia> apisrs = load_data(\"apisrs\");\n\njulia> srs = SurveyDesign(apisrs; weights=:pw);\n\njulia> sturges(srs, :enroll)\n9\n\n\n\n\n\n","category":"function"},{"location":"api/#Survey.freedman_diaconis","page":"API reference","title":"Survey.freedman_diaconis","text":"freedman_diaconis(design::SurveyDesign, var::Symbol)\n\nCalculate the number of bins to use in a histogram using the Freedman-Diaconis rule.\n\nExamples\n\njulia> apisrs = load_data(\"apisrs\");\n\njulia> srs = SurveyDesign(apisrs; weights=:pw);\n\njulia> freedman_diaconis(srs, :enroll)\n18\n\n\n\n\n\n","category":"function"},{"location":"man/glm/#Generalized-Linear-Models-in-Survey","page":"Generalised linear models","title":"Generalized Linear Models in Survey","text":"","category":"section"},{"location":"man/glm/","page":"Generalised linear models","title":"Generalised linear models","text":"The glm() function in the Julia Survey package is used to fit generalized linear models (GLMs) to survey data. It incorporates survey design information, such as sampling weights, stratification, and clustering, to produce valid estimates and standard errors that account for the type of survey design.","category":"page"},{"location":"man/glm/","page":"Generalised linear models","title":"Generalised linear models","text":"As of June 2023, the GLM.jl documentation lists the supported distribution families and their link functions as:","category":"page"},{"location":"man/glm/","page":"Generalised linear models","title":"Generalised linear models","text":"Bernoulli (LogitLink)\nBinomial (LogitLink)\nGamma (InverseLink)\nInverseGaussian (InverseSquareLink)\nNegativeBinomial (NegativeBinomialLink, often used with LogLink)\nNormal (IdentityLink)\nPoisson (LogLink)","category":"page"},{"location":"man/glm/","page":"Generalised linear models","title":"Generalised linear models","text":"Refer to the GLM.jl documentation for more information about the GLM package.","category":"page"},{"location":"man/glm/#Fitting-a-GLM-to-a-Survey-Design-object","page":"Generalised linear models","title":"Fitting a GLM to a Survey Design object","text":"","category":"section"},{"location":"man/glm/","page":"Generalised linear models","title":"Generalised linear models","text":"You can fit a GLM to a Survey Design object the same way you would fit it to a regular data frame. The only difference is that you need to specify the survey design object as the second argument to the glm() function.","category":"page"},{"location":"man/glm/","page":"Generalised linear models","title":"Generalised linear models","text":"using Survey\napisrs = load_data(\"apisrs\") \n\n# Simple random sample survey\nsrs = SurveyDesign(apisrs, weights = :pw) \n\n# Survey stratified by stype\ndstrat = SurveyDesign(apistrat, strata = :stype, weights = :pw) \n\n# Survey clustered by dnum\ndclus1 = SurveyDesign(apiclus1, clusters = :dnum, weights = :pw) ","category":"page"},{"location":"man/glm/","page":"Generalised linear models","title":"Generalised linear models","text":"Once you have the survey design object, you can fit a GLM using the glm() function. Specify the formula for the model and the distribution family. ","category":"page"},{"location":"man/glm/","page":"Generalised linear models","title":"Generalised linear models","text":"The glm() function supports all distribution families supported by GLM.jl, i.e. Bernoulli, Binomial, Gamma, Geometric, InverseGaussian, NegativeBinomial, Normal, and Poisson. ","category":"page"},{"location":"man/glm/","page":"Generalised linear models","title":"Generalised linear models","text":"For example, to fit a GLM with a Bernoulli distribution and a Logit link function to the srs survey design object we created above:","category":"page"},{"location":"man/glm/","page":"Generalised linear models","title":"Generalised linear models","text":"formula = @formula(api00 ~ api99)\nmy_glm = glm(formula, srs, family = Normal())\n\n# View the coefficients and standard errors\nmy_glm.Coefficients\nmy_glm.SE","category":"page"},{"location":"man/glm/#Examples","page":"Generalised linear models","title":"Examples","text":"","category":"section"},{"location":"man/glm/","page":"Generalised linear models","title":"Generalised linear models","text":"The examples below use the api datasets, which contain survey data collected about California schools. The datasets are included in the Survey.jl package and can be loaded by calling load_data(\"name_of_dataset\").","category":"page"},{"location":"man/glm/#Bernoulli-with-Logit-Link","page":"Generalised linear models","title":"Bernoulli with Logit Link","text":"","category":"section"},{"location":"man/glm/","page":"Generalised linear models","title":"Generalised linear models","text":"A school being eligible for the awards program (awards) is a binary outcome (0 or 1). Let's assume it follows a Bernoulli distribution. Suppose we want to predict awards based on the percentage of students eligible for subsidized meals (meals) and the percentage of English Language Learners (ell). We can fit this GLM using the code below:","category":"page"},{"location":"man/glm/","page":"Generalised linear models","title":"Generalised linear models","text":"using Survey\napisrs = load_data(\"apisrs\")\nsrs = SurveyDesign(apisrs, weights = :pw) \n\n# Convert yes/no to 1/0\napisrs.awards = ifelse.(apisrs.awards .== \"Yes\", 1, 0)\n\n# Fit the model\nmodel = glm(@formula(awards ~ meals + ell), apisrs, Bernoulli(), LogitLink())","category":"page"},{"location":"man/glm/#Poisson-with-Log-Link","page":"Generalised linear models","title":"Poisson with Log Link","text":"","category":"section"},{"location":"man/glm/","page":"Generalised linear models","title":"Generalised linear models","text":"Let us assume that the number of students tested (api_stu) follows a Poisson distribution, which models the number of successes out of a fixed number of trials. Suppose we want to predict the number of students tested based on the percentage of students eligible for subsidized meals (meals) and the percentage of English Language Learners (ell). We can fit this GLM using the code below:","category":"page"},{"location":"man/glm/","page":"Generalised linear models","title":"Generalised linear models","text":"using Survey\napisrs = load_data(\"apisrs\")\nsrs = SurveyDesign(apisrs, weights = :pw) \n\n# Rename api.stu to api_stu\nrename!(apisrs, Symbol(\"api.stu\") => :api_stu)\n\n# Fit the model\nmodel = glm(@formula(api_stu ~ meals + ell), apisrs, Poisson(), LogLink())","category":"page"},{"location":"man/glm/#Gamma-with-Inverse-Link","page":"Generalised linear models","title":"Gamma with Inverse Link","text":"","category":"section"},{"location":"man/glm/","page":"Generalised linear models","title":"Generalised linear models","text":"Let us assume that the average parental education level (avg_ed) follows a Gamma distribution, which is suitable for modeling continuous, positive-valued variables with a skewed distribution. Suppose we want to predict the average parental education level based on the percentage of students eligible for subsidized meals (meals) and the percentage of English Language Learners (ell). We can fit this GLM using the code below:","category":"page"},{"location":"man/glm/","page":"Generalised linear models","title":"Generalised linear models","text":"using Survey\napisrs = load_data(\"apisrs\")\nsrs = SurveyDesign(apisrs, weights = :pw) \n\n# Rename api.stu to api_stu\nrename!(apisrs, Symbol(\"avg.ed\") => :avg_ed)\n\n# Fit the model\nmodel = glm(@formula(avg_ed  ~ meals + ell), apisrs, Gamma(), InverseLink())","category":"page"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The Survey.jl package is registered. Regular Pkg commands can be used for installing the package:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Pkg\n\nPkg.add(\"Survey\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"]  add Survey","category":"page"},{"location":"getting_started/#Tutorial","page":"Getting Started","title":"Tutorial","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This tutorial assumes basic knowledge of statistics and survey analysis.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To begin this tutorial, load the package in your workspace:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Survey","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Now load a survey dataset that you want to study. In this tutorial we will be using the Academic Performance Index (API) datasets for Californian schools. The datasets contain information for all schools with at least 100 students and for various probability samples of the data.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"apisrs = load_data(\"apisrs\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"apisrs is a simple random sample of the Academic Performance Index of Californian schools. The load_data function loads it as a DataFrame. You can look at the column names of apisrs to get an idea of what the dataset contains.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"names(apisrs)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Next, build a survey design from your DataFrame:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"srs = SurveyDesign(apisrs; weights=:pw)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This is a simple random sample design with weights given by the column :pw of apisrs. You can also create more complex designs such as stratified or cluster sample designs. You can find more information on the complete capabilities of the package in the Manual. The purpose of this tutorial is to show the basic usage of the package. For that, we will stick with a simple random sample.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Now you can analyse your design according to your needs using the functionality provided by the package. For example, you can compute the estimated mean or population total for a given variable. Let's say you want to find the mean Academic Performance Index from the year 1999. If you are only interested in the estimated mean, then you can directly pass your design to the mean function:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"mean(:api99, srs)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"If you also want to know the standard error of the mean, you need to convert the SurveyDesign to a ReplicateDesign using bootstrapping:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"bsrs = bootweights(srs; replicates = 1000)\nmean(:api99, bsrs)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"You can find the mean of both the 1999 API and 2000 API for a clear comparison between students' performance from one year to another:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"mean([:api99, :api00], bsrs)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The ratio is also appropriate for studying the relationship between the two APIs:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"ratio(:api00, :api99, bsrs)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"If you're interested in a certain statistic estimated by a specific domain, you can add the domain as the second parameter to your function. Let's say you want to find the estimated total number of students enrolled in schools from each county:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"total(:enroll, :cname, bsrs)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Another way to visualize data is through graphs. You can make a histogram to better see the distribution of enrolled students:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# !!!THIS NEEDS TO MATCH THE EXAMPLE IN THE DOCSTRING OF `hist`","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> hist(srs, :enroll)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The REPL doesn't show the plot. To see it, you need to save it locally.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> import AlgebraOfGraphics.save\n\njulia> save(\"hist.png\", h)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"man/comparisons/#Comparison-with-other-survey-analysis-tools","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"There are multiple alternatives that offer survey analysis tools, most notably SAS, Stata and R.","category":"page"},{"location":"man/comparisons/#R-comparison","page":"Comparison with other survey analysis tools","title":"R comparison","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"The inspiration for Survey.jl comes from R. Hence the syntax is in most cases very similar to the syntax in the survey package from R. To showcase this we will use the api datasets found in both R's survey and Survey.jl. See the Tutorial section for more details about the api datesets.","category":"page"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"All examples show the R code first, followed by the Julia code.","category":"page"},{"location":"man/comparisons/#Loading-data","page":"Comparison with other survey analysis tools","title":"Loading data","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"> data(api)\n# all `api` datasets are loaded globally","category":"page"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"julia> srs = load_data(\"apisrs\")\n# only one dataset is loaded and stored in a variable","category":"page"},{"location":"man/comparisons/#Creating-a-design","page":"Comparison with other survey analysis tools","title":"Creating a design","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"> srs = svydesign(id=~1, data=apisrs, weights=~pw) # simple random sample\n> dstrat = svydesign(id=~1, data=apistrat, strata=~stype, weights=~pw) # stratified\n> clus1 = svydesign(id=~dnum, data=apiclus1, weights=~pw) # clustered (one stage)","category":"page"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"julia> srs = SurveyDesign(apisrs; weights=:pw) # simple random sample\njulia> dstrat = SurveyDesign(apistrat; strata=:stype, weights=:pw) # stratified\njulia> clus1 = SurveyDesign(apiclus1; clusters=:dnum, weights=:pw) # clustered (one stage)","category":"page"},{"location":"man/comparisons/#Creating-a-replicate-design","page":"Comparison with other survey analysis tools","title":"Creating a replicate design","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"> bsrs = as.svrepdesign(srs, type=\"subbootstrap\")","category":"page"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"julia> bsrs = bootweights(srs)","category":"page"},{"location":"man/comparisons/#Computing-the-estimated-mean","page":"Comparison with other survey analysis tools","title":"Computing the estimated mean","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"> svymean(~api00, bsrs)\n> svymean(~api99+~api00, bsrs)","category":"page"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"julia> mean(:api00, bsrs)\njulia> mean([:api99, :api00], bsrs)","category":"page"},{"location":"man/comparisons/#Computing-the-estimated-total","page":"Comparison with other survey analysis tools","title":"Computing the estimated total","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"> svytotal(~api00, bsrs)\n> svytotal(~api99+~api00, bsrs)","category":"page"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"julia> total(:api00, bsrs)\njulia> total([:api99, :api00], bsrs)","category":"page"},{"location":"man/comparisons/#Computing-quantiles","page":"Comparison with other survey analysis tools","title":"Computing quantiles","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"> svyquantile(~api00, bsrs, 0.5)\n> svyquantile(~api00, bsrs, c(0.25, 0.5, 0.75))","category":"page"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"julia> quantile(:api00, bsrs, 0.5)\njulia> quantile(:api00, bsrs, [0.25, 0.5, 0.75])","category":"page"},{"location":"man/comparisons/#Domain-estimation","page":"Comparison with other survey analysis tools","title":"Domain estimation","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"> svyby(~api00, ~cname, bsrs, svymean)","category":"page"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"julia> mean(:api00, :cname, bsrs)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Survey","category":"page"},{"location":"#Survey","page":"Home","title":"Survey","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is used to study complex survey data. It aims to provide an efficient computing framework for survey analysis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Surveys are a standard tool for empirical research in social and behavioral sciences, and also widely used by governments and businesses.  To obtain a better representation of a population and more precise estimates, complex surveys use sampling techniques like clustering, stratification, unequal probability selection or a combination of these.  Computing population estimates from a survey with corresponding standard errors requires several corrections, weights calibrations and adjustments. A \"survey\" package automatically applies several of these mathematical techniques and exposes an intuitive API to the user.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Sizes of survey datasets have also been growing with advances in computing power and storage, as well as ease of administering surveys online and over wider geographic areas. This Julia package aims to provide an efficient framework for rapidly growing sizes of survey datasets.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Several software tools are available to study complex surveys[1]. The survey package in R is a widely used open-source package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Discourse post announcing the package.","category":"page"},{"location":"#Current-features","page":"Home","title":"Current features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Presently, summary statistics such as mean, total, ratio, and quantile can be estimated for whole of sample as well as subpopulations/domains using this package. Variance estimation for these estimators are performed using Rao-Wu bootstrap[2]. Basic visualisations such a scatter plot, histogram and box plot can also be generated. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package is built on top of DataFrames.jl and supports a variety of features for data manipulation. Plots are generated using AlgebraOfGraphics.","category":"page"},{"location":"#Plans","page":"Home","title":"Plans","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We plan for efficient implementations of all the methods in R survey. Features for future releases will include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Proportion and count estimation\nVariance by Taylor linearization for SurveyDesign\nSupport additional replicate weighting algorithms (BRR, Jackknife, other bootstrap flavors) for ReplicateDesign\nBetter support for more complex survey designs, including more precise estimators for specific designs\nPost-stratification, raking or calibration, GREG estimation and related methods.\nFrequency/contingency table analysis, association tests\nSurvival curves and analysis tools\nIntegration with GLM.jl\nSupport for CategoricalsArrays\nMultivariate analysis, principal components  \nSupport for imputing missing data\nIntegration with CRRao.jl ","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]: Comprehensive list of survey analysis software.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2]: Rust, Keith F., and J. N. K. Rao. \"Variance estimation for complex surveys using replication techniques.\", Statistical methods in medical research 5.3 (1996): 283-310.","category":"page"},{"location":"man/dataframes/#manual","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"","category":"section"},{"location":"man/dataframes/","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"The internal structure of a survey design is build upon DataFrames. In fact, the data argument is the only required argument for the constructor, and it must be an AbstractDataFrame.","category":"page"},{"location":"man/dataframes/#Data-manipulation","page":"DataFrames in Survey","title":"Data manipulation","text":"","category":"section"},{"location":"man/dataframes/","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"The provided DataFrame is altered by the SurveyDesign constructor in order to add columns for frequency and probability weights, sample and population sizes and, if necessary, strata and cluster information.","category":"page"},{"location":"man/dataframes/","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"Notice the change in apisrs:","category":"page"},{"location":"man/dataframes/","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"using Survey","category":"page"},{"location":"man/dataframes/","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"apisrs = load_data(\"apisrs\")\nnames(apisrs)\nsrs = SurveyDesign(apisrs; weights=:pw);\napisrs\nnames(apisrs)","category":"page"},{"location":"man/dataframes/","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"Five columns were added:","category":"page"},{"location":"man/dataframes/","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"false_strata - only in the case of no stratification\nThis column is necessary because when making a ReplicateDesign, the bootweights function uses groupby with a column representing the stratification variable. If there are no strata, there is no such column, so it should be added in order to keep bootweights general.\nfalse_cluster - only in the case of no clustering\nThe reasoning is the same as in the case of no stratification.\n_sampsize - sample sizes\n_popsize - population sizes\nThese match the stratification variable:","category":"page"},{"location":"man/dataframes/","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"apistrat = load_data(\"apistrat\");\ndstrat = SurveyDesign(apistrat; strata=:stype, weights=:pw);\napistrat[:, [:stype, :_sampsize, :_popsize]]","category":"page"},{"location":"man/dataframes/","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"_allprobs - probability weights","category":"page"},{"location":"man/dataframes/","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"No column was added for frequency weights because the column passed through the weights argument is used by other functions, hence there is no need to add a new column. If weights is not specified, then a column called _weights is added.","category":"page"}]
}
