var documenterSearchIndex = {"docs":
[{"location":"man/plotting/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"Survey uses AlgebraOfGraphics for plotting. All plotting functions support a variable number of keyword arguments (through kwargs...) that are passed internally to corresponding AlgebraOfGraphics functions. See the source code for details: plot, hist, boxplot. This means that all functionality provided by AlgebraOfGraphics is supported in Survey.","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"Specific functionality might need to be imported from AlgebraOfGraphics. Moreover, in order to choose the preferred Makie backend you must explicitly use it:","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"using AlgebraOfGraphics, CairoMakie","category":"page"},{"location":"man/replicate/#Replicate-weights","page":"Replicate weights","title":"Replicate weights","text":"","category":"section"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"Replicate weights are a method for estimating the standard errors of survey statistics in complex sample designs.","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"The basic idea behind replicate weights is to create multiple versions of the original sample weights, each with small, randomly generated perturbations. The multiple versions of the sample weights are then used to calculate the survey statistic of interest, such as the mean or total, on multiple replicate samples. The variance of the survey statistic is then estimated by computing the variance across the replicate samples.","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"Currently, the Rao-Wu bootstrap[1] is the only method in the package for generating replicate weights. ","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"The bootweights function of the package can be used to generate a ReplicateDesign from a SurveyDesign For example: ","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"using Survey\napistrat = load_data(\"apistrat\")\ndstrat = SurveyDesign(apistrat; strata=:stype, weights=:pw)\nbstrat = bootweights(dstrat; replicates = 10)","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"For each replicate, the DataFrame of ReplicateDesign has an additional column. The of the column is replicate_ followed by the replicate number.  ","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"names(bstrat.data)","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"replicate_1, replicate_2, replicate_3, replicate_4, replicate_5, replicate_6, replicate_7, replicate_8, replicate_9, replicate_10, are the replicate weight columns. ","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"While a SurveyDesign can be used to estimate a statistics. For example: ","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"mean(:api00, dstrat)","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"The ReplicateDesign can be used to compute the standard error of the statistic. For example: ","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"mean(:api00, bstrat)","category":"page"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"For each replicate weight, the statistic is calculated using it instead of the weight. The standard deviation of those statistics is the standard error of the estimate.  ","category":"page"},{"location":"man/replicate/#References","page":"Replicate weights","title":"References","text":"","category":"section"},{"location":"man/replicate/","page":"Replicate weights","title":"Replicate weights","text":"[1]: Rust, Keith F., and J. N. K. Rao. \"Variance estimation for complex surveys using replication techniques.\" Statistical methods in medical research 5.3 (1996): 283-310.","category":"page"},{"location":"api/#API","page":"API reference","title":"API","text":"","category":"section"},{"location":"api/#Index","page":"API reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Module = [Survey]\nOrder = [:type, :function]\nPrivate = false","category":"page"},{"location":"api/","page":"API reference","title":"API reference","text":"AbstractSurveyDesign\nSurveyDesign\nReplicateDesign\nload_data\nbootweights\njackknifeweights\njackknife_variance\nmean\ntotal\nquantile\nratio\nplot\nboxplot\nhist","category":"page"},{"location":"api/#Survey.AbstractSurveyDesign","page":"API reference","title":"Survey.AbstractSurveyDesign","text":"AbstractSurveyDesign\n\nSupertype for every survey design type. \n\nnote: Note\nThe data passed to a survey constructor is modified. To avoid this pass a copy of the data instead of the original.\n\n\n\n\n\n","category":"type"},{"location":"api/#Survey.SurveyDesign","page":"API reference","title":"Survey.SurveyDesign","text":"SurveyDesign <: AbstractSurveyDesign\n\nGeneral survey design encompassing a simple random, stratified, cluster or multi-stage design.\n\nIn the case of cluster sample, the clusters are chosen by simple random sampling. All individuals in one cluster are sampled. The clusters are considered disjoint and nested.\n\nstrata and clusters must be given as columns in data.\n\nArguments:\n\ndata::AbstractDataFrame: the survey dataset (!this gets modified by the constructor).\nstrata::Union{Nothing, Symbol}=nothing: the stratification variable.\nclusters::Union{Nothing, Symbol, Vector{Symbol}}=nothing: the clustering variable.\nweights::Union{Nothing, Symbol}=nothing: the sampling weights.\npopsize::Union{Nothing, Symbol}=nothing: the (expected) survey population size.\n\njulia> apiclus1 = load_data(\"apiclus1\");\n\njulia> dclus1 = SurveyDesign(apiclus1; clusters=:dnum, weights=:pw)\nSurveyDesign:\ndata: 183×44 DataFrame\nstrata: none\ncluster: dnum\n    [637, 637, 637  …  448]\npopsize: [507.7049, 507.7049, 507.7049  …  507.7049]\nsampsize: [15, 15, 15  …  15]\nweights: [33.847, 33.847, 33.847  …  33.847]\nallprobs: [0.0295, 0.0295, 0.0295  …  0.0295]\n\n\n\n\n\n","category":"type"},{"location":"api/#Survey.ReplicateDesign","page":"API reference","title":"Survey.ReplicateDesign","text":"ReplicateDesign <: AbstractSurveyDesign\n\nSurvey design obtained by replicating an original design using bootweights. If replicate weights are available, then they can be used to directly create a ReplicateDesign.\n\nConstructors\n\nReplicateDesign(\n    data::AbstractDataFrame,\n    replicate_weights::Vector{Symbol};\n    clusters::Union{Nothing,Symbol,Vector{Symbol}} = nothing,\n    strata::Union{Nothing,Symbol} = nothing,\n    popsize::Union{Nothing,Symbol} = nothing,\n    weights::Union{Nothing,Symbol} = nothing\n)\n\nReplicateDesign(\n    data::AbstractDataFrame,\n    replicate_weights::UnitIndex{Int};\n    clusters::Union{Nothing,Symbol,Vector{Symbol}} = nothing,\n    strata::Union{Nothing,Symbol} = nothing,\n    popsize::Union{Nothing,Symbol} = nothing,\n    weights::Union{Nothing,Symbol} = nothing\n)\n\nReplicateDesign(\n    data::AbstractDataFrame,\n    replicate_weights::Regex;\n    clusters::Union{Nothing,Symbol,Vector{Symbol}} = nothing,\n    strata::Union{Nothing,Symbol} = nothing,\n    popsize::Union{Nothing,Symbol} = nothing,\n    weights::Union{Nothing,Symbol} = nothing\n)\n\nArguments\n\nThe constructor has the same arguments as SurveyDesign. The only additional argument is replicate_weights, which can be of one of the following types.\n\nVector{Symbol}: In this case, each Symbol in the vector should represent a column of data containing the replicate weights.\nUnitIndex{Int}: For instance, this could be UnitRange(5:10). This will mean that the replicate weights are contained in columns 5 through 10.\nRegex: In this case, all the columns of data which match this Regex will be treated as the columns containing the replicate weights.\n\nAll the columns containing the replicate weights will be renamed to the form replicate_i, where i ranges from 1 to the number of columns containing the replicate weights.\n\nExamples\n\nHere is an example where the bootweights function is used to create a ReplicateDesign.\n\njulia> apistrat = load_data(\"apistrat\");\n\njulia> dstrat = SurveyDesign(apistrat; strata=:stype, weights=:pw);\n\njulia> bootstrat = bootweights(dstrat; replicates=1000)     # creating a ReplicateDesign using bootweights\nReplicateDesign:\ndata: 200×1044 DataFrame\nstrata: stype\n    [E, E, E  …  H]\ncluster: none\npopsize: [4420.9999, 4420.9999, 4420.9999  …  755.0]\nsampsize: [100, 100, 100  …  50]\nweights: [44.21, 44.21, 44.21  …  15.1]\nallprobs: [0.0226, 0.0226, 0.0226  …  0.0662]\ntype: bootstrap\nreplicates: 1000\n\n\nIf the replicate weights are given to us already, then we can directly pass them to the ReplicateDesign constructor. For instance, in the above example, suppose we had the bootstrat data as a CSV file (for this example, we also rename the columns containing the replicate weights to the form r_i).\n\njulia> using CSV;\n\njulia> DataFrames.rename!(bootstrat.data, [\"replicate_\"*string(index) => \"r_\"*string(index) for index in 1:1000]);\n\njulia> CSV.write(\"apistrat_withreplicates.csv\", bootstrat.data);\n\n\nWe can now pass the replicate weights directly to the ReplicateDesign constructor, either as a Vector{Symbol}, a UnitRange or a Regex.\n\njulia> bootstrat_direct = ReplicateDesign(CSV.read(\"apistrat_withreplicates.csv\", DataFrame), [Symbol(\"r_\"*string(replicate)) for replicate in 1:1000]; strata=:stype, weights=:pw)\nReplicateDesign:\ndata: 200×1044 DataFrame\nstrata: stype\n    [E, E, E  …  H]\ncluster: none\npopsize: [4420.9999, 4420.9999, 4420.9999  …  755.0]\nsampsize: [100, 100, 100  …  50]\nweights: [44.21, 44.21, 44.21  …  15.1]\nallprobs: [0.0226, 0.0226, 0.0226  …  0.0662]\ntype: bootstrap\nreplicates: 1000\n\njulia> bootstrat_unitrange = ReplicateDesign(CSV.read(\"apistrat_withreplicates.csv\", DataFrame), UnitRange(45:1044);strata=:stype, weights=:pw)\nReplicateDesign:\ndata: 200×1044 DataFrame\nstrata: stype\n    [E, E, E  …  H]\ncluster: none\npopsize: [4420.9999, 4420.9999, 4420.9999  …  755.0]\nsampsize: [100, 100, 100  …  50]\nweights: [44.21, 44.21, 44.21  …  15.1]\nallprobs: [0.0226, 0.0226, 0.0226  …  0.0662]\ntype: bootstrap\nreplicates: 1000\n\njulia> bootstrat_regex = ReplicateDesign(CSV.read(\"apistrat_withreplicates.csv\", DataFrame), r\"r_\\d\";strata=:stype, weights=:pw)\nReplicateDesign:\ndata: 200×1044 DataFrame\nstrata: stype\n    [E, E, E  …  H]\ncluster: none\npopsize: [4420.9999, 4420.9999, 4420.9999  …  755.0]\nsampsize: [100, 100, 100  …  50]\nweights: [44.21, 44.21, 44.21  …  15.1]\nallprobs: [0.0226, 0.0226, 0.0226  …  0.0662]\ntype: bootstrap\nreplicates: 1000\n\n\n\n\n\n\n","category":"type"},{"location":"api/#Survey.load_data","page":"API reference","title":"Survey.load_data","text":"load_data(name)\n\nLoad a sample dataset as a DataFrame.\n\nAll available datasets can be found here.\n\njulia> apisrs = load_data(\"apisrs\")\n200×40 DataFrame\n Row │ Column1  cds             stype    name             sname                ⋯\n     │ Int64    Int64           String1  String15         String               ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │    1039  15739081534155  H        McFarland High   McFarland High       ⋯\n   2 │    1124  19642126066716  E        Stowers (Cecil   Stowers (Cecil B.) E\n   3 │    2868  30664493030640  H        Brea-Olinda Hig  Brea-Olinda High\n   4 │    1273  19644516012744  E        Alameda Element  Alameda Elementary\n   5 │    4926  40688096043293  E        Sunnyside Eleme  Sunnyside Elementary ⋯\n   6 │    2463  19734456014278  E        Los Molinos Ele  Los Molinos Elementa\n   7 │    2031  19647336058200  M        Northridge Midd  Northridge Middle\n   8 │    1736  19647336017271  E        Glassell Park E  Glassell Park Elemen\n  ⋮  │    ⋮           ⋮            ⋮            ⋮                       ⋮      ⋱\n 194 │    4880  39686766042782  E        Tyler Skills El  Tyler Skills Element ⋯\n 195 │     993  15636851531987  H        Desert Junior/S  Desert Junior/Senior\n 196 │     969  15635291534775  H        North High       North High\n 197 │    1752  19647336017446  E        Hammel Street E  Hammel Street Elemen\n 198 │    4480  37683386039143  E        Audubon Element  Audubon Elementary   ⋯\n 199 │    4062  36678196036222  E        Edison Elementa  Edison Elementary\n 200 │    2683  24657716025621  E        Franklin Elemen  Franklin Elementary\n                                                 36 columns and 185 rows omitted\n\n\n\n\n\n","category":"function"},{"location":"api/#Survey.bootweights","page":"API reference","title":"Survey.bootweights","text":"Use bootweights to create replicate weights using Rao-Wu bootstrap. The function accepts a SurveyDesign and returns a ReplicateDesign which has additional columns for replicate weights. \n\njulia> using Random\n\njulia> apiclus1 = load_data(\"apiclus1\");\n\njulia> dclus1 = SurveyDesign(apiclus1; clusters = :dnum, popsize=:fpc);\n\njulia> bootweights(dclus1; replicates=1000, rng=MersenneTwister(111)) # choose a seed for deterministic results\nReplicateDesign:\ndata: 183×1044 DataFrame\nstrata: none\ncluster: dnum\n    [61, 61, 61  …  815]\npopsize: [757, 757, 757  …  757]\nsampsize: [15, 15, 15  …  15]\nweights: [50.4667, 50.4667, 50.4667  …  50.4667]\nallprobs: [0.0198, 0.0198, 0.0198  …  0.0198]\ntype: bootstrap\nreplicates: 1000\n\n\n\n\n\n","category":"function"},{"location":"api/#Survey.jackknifeweights","page":"API reference","title":"Survey.jackknifeweights","text":"jackknifeweights(design::SurveyDesign)\n\nDelete-1 Jackknife algorithm for replication weights from sampling weights. The replicate weights are calculated using the following formula.\n\nw_i(hj) =\nbegincases\n    w_iquadquad textif observation unit itext is not in stratum h\n    0quadquad textif observation unit itext is in psu jtextof stratum h\n    dfracn_hn_h - 1w_i quadquad textif observation unit itext is in stratum htext but not in psu j\nendcases\n\nIn the above formula, w_i represent the original weights, w_i(hj) represent the replicate weights when the jth PSU from cluster h is removed, and n_h represents the number of unique PSUs within cluster h. Replicate weights are added as columns to design.data, and these columns have names of the form replicate_i, where i ranges from 1 to the number of replicate weight columns.\n\nExamples\n\njulia> using Survey;\n\njulia> apistrat = load_data(\"apistrat\");\n\njulia> dstrat = SurveyDesign(apistrat; strata=:stype, weights=:pw);\n\njulia> rstrat = jackknifeweights(dstrat)\nReplicateDesign:\ndata: 200×244 DataFrame\nstrata: stype\n    [E, E, E  …  M]\ncluster: none\npopsize: [4420.9999, 4420.9999, 4420.9999  …  1018.0]\nsampsize: [100, 100, 100  …  50]\nweights: [44.21, 44.21, 44.21  …  20.36]\nallprobs: [0.0226, 0.0226, 0.0226  …  0.0491]\ntype: jackknife\nreplicates: 200\n\n\nReference\n\npg 380-382, Section 9.3.2 Jackknife - Sharon Lohr, Sampling Design and Analysis (2010)\n\n\n\n\n\n","category":"function"},{"location":"api/#Survey.jackknife_variance","page":"API reference","title":"Survey.jackknife_variance","text":"jackknife_variance(x::Symbol, func::Function, design::ReplicateDesign)\n\nCompute variance of column x for the given func using the Jackknife method. The formula to compute this variance is the following.\n\nhatV_textJK(hattheta) = sum_h = 1^H dfracn_h - 1n_hsum_j = 1^n_h(hattheta_(hj) - hattheta)^2\n\nAbove, hattheta represents the estimator computed using the original weights, and hattheta_(hj) represents the estimator computed from the replicate weights obtained when PSU j from cluster h is removed.\n\nExamples\n\njulia> using Survey, StatsBase\n\njulia> apistrat = load_data(\"apistrat\");\n\njulia> dstrat = SurveyDesign(apistrat; strata=:stype, weights=:pw);\n\njulia> rstrat = jackknifeweights(dstrat)\nReplicateDesign:\ndata: 200×244 DataFrame\nstrata: stype\n    [E, E, E  …  M]\ncluster: none\npopsize: [4420.9999, 4420.9999, 4420.9999  …  1018.0]\nsampsize: [100, 100, 100  …  50]\nweights: [44.21, 44.21, 44.21  …  20.36]\nallprobs: [0.0226, 0.0226, 0.0226  …  0.0491]\ntype: jackknife\nreplicates: 200\n\njulia> weightedmean(x, y) = mean(x, weights(y));\n\njulia> jackknife_variance(:api00, weightedmean, rstrat)\n1×2 DataFrame\n Row │ estimator  SE\n     │ Float64    Float64\n─────┼────────────────────\n   1 │   662.287  9.53613\n\n\nReference\n\npg 380-382, Section 9.3.2 Jackknife - Sharon Lohr, Sampling Design and Analysis (2010)\n\n\n\n\n\n","category":"function"},{"location":"api/#Statistics.mean","page":"API reference","title":"Statistics.mean","text":"mean(var, design)\n\nEstimate the mean of a variable.\n\njulia> apiclus1 = load_data(\"apiclus1\");\n\njulia> dclus1 = SurveyDesign(apiclus1; clusters = :dnum, weights = :pw)\nSurveyDesign:\ndata: 183×44 DataFrame\nstrata: none\ncluster: dnum\n    [637, 637, 637  …  448]\npopsize: [507.7049, 507.7049, 507.7049  …  507.7049]\nsampsize: [15, 15, 15  …  15]\nweights: [33.847, 33.847, 33.847  …  33.847]\nallprobs: [0.0295, 0.0295, 0.0295  …  0.0295]\n\njulia> mean(:api00, dclus1)\n1×1 DataFrame\n Row │ mean\n     │ Float64\n─────┼─────────\n   1 │ 644.169 \n\n\n\n\n\nUse replicate weights to compute the standard error of the estimated mean. \n\njulia> bclus1 = dclus1 |> bootweights;\n\njulia> mean(:api00, bclus1)\n1×2 DataFrame\n Row │ mean     SE\n     │ Float64  Float64\n─────┼──────────────────\n   1 │ 644.169  23.4107\n\n\n\n\n\nEstimate the mean of a list of variables.\n\njulia> mean([:api00, :enroll], dclus1)\n2×2 DataFrame\n Row │ names   mean\n     │ String  Float64\n─────┼─────────────────\n   1 │ api00   644.169\n   2 │ enroll  549.716\n\nUse replicate weights to compute the standard error of the estimated means. \n\njulia> mean([:api00, :enroll], bclus1)\n2×3 DataFrame\n Row │ names   mean     SE\n     │ String  Float64  Float64\n─────┼──────────────────────────\n   1 │ api00   644.169  23.4107\n   2 │ enroll  549.716  45.7835 \n\n\n\n\n\nmean(var, domain, design)\n\nEstimate means of domains.\n\njulia> mean(:api00, :cname, dclus1)\n11×2 DataFrame\n Row │ cname        mean\n     │ String15     Float64\n─────┼──────────────────────\n   1 │ Alameda      669.0\n   2 │ Fresno       472.0\n   3 │ Kern         452.5\n   4 │ Los Angeles  647.267\n   5 │ Mendocino    623.25\n   6 │ Merced       519.25\n   7 │ Orange       710.563\n   8 │ Plumas       709.556\n   9 │ San Diego    659.436\n  10 │ San Joaquin  551.189\n  11 │ Santa Clara  732.077 \n\nUse the replicate design to compute standard errors of the estimated means. \n\njulia> mean(:api00, :cname, bclus1)\n11×3 DataFrame\n Row │ cname        mean     SE\n     │ String15     Float64  Float64\n─────┼────────────────────────────────────\n   1 │ Santa Clara  732.077  58.2169\n   2 │ San Diego    659.436   2.66703\n   3 │ Merced       519.25    2.28936e-15\n   4 │ Los Angeles  647.267  47.6233\n   5 │ Orange       710.563   2.19826e-13\n   6 │ Fresno       472.0     1.13687e-13\n   7 │ Plumas       709.556   1.26058e-13\n   8 │ Alameda      669.0     1.27527e-13\n   9 │ San Joaquin  551.189   2.1791e-13\n  10 │ Kern         452.5     0.0\n  11 │ Mendocino    623.25    1.09545e-13\n\n\n\n\n\n","category":"function"},{"location":"api/#Survey.total","page":"API reference","title":"Survey.total","text":"total(var, design)\n\nEstimate the population total of variable.\n\njulia> apiclus1 = load_data(\"apiclus1\");\n\njulia> dclus1 = SurveyDesign(apiclus1; clusters = :dnum, weights = :pw);\n\njulia> total(:api00, dclus1)\n1×1 DataFrame\n Row │ total\n     │ Float64\n─────┼───────────\n   1 │ 3.98999e6\n\n\n\n\n\nUse replicate weights to compute the standard error of the estimated total. \n\njulia> bclus1 = dclus1 |> bootweights;\n\njulia> total(:api00, bclus1)\n1×2 DataFrame\n Row │ total      SE\n     │ Float64    Float64\n─────┼──────────────────────\n   1 │ 3.98999e6  9.01611e5\n\n\n\n\n\nEstimate the population total of a list of variables.\n\njulia> total([:api00, :enroll], dclus1)\n2×2 DataFrame\n Row │ names   total\n     │ String  Float64\n─────┼───────────────────\n   1 │ api00   3.98999e6\n   2 │ enroll  3.40494e6\n\nUse replicate weights to compute the standard error of the estimated means. \n\njulia> total([:api00, :enroll], bclus1)\n2×3 DataFrame\n Row │ names   total      SE\n     │ String  Float64    Float64\n─────┼──────────────────────────────\n   1 │ api00   3.98999e6  9.01611e5\n   2 │ enroll  3.40494e6  9.33396e5 \n\n\n\n\n\ntotal(var, domain, design)\n\nEstimate population totals of domains.\n\njulia> total(:api00, :cname, dclus1)\n11×2 DataFrame\n Row │ cname        total\n     │ String15     Float64\n─────┼─────────────────────────────\n   1 │ Alameda      249080.0\n   2 │ Fresno        63903.1\n   3 │ Kern          30631.5\n   4 │ Los Angeles       3.2862e5\n   5 │ Mendocino     84380.6\n   6 │ Merced        70300.2\n   7 │ Orange            3.84807e5\n   8 │ Plumas            2.16147e5\n   9 │ San Diego         1.2276e6\n  10 │ San Joaquin       6.90276e5\n  11 │ Santa Clara       6.44244e5 \n\nUse the replicate design to compute standard errors of the estimated totals. \n\njulia> total(:api00, :cname, bclus1)\n11×3 DataFrame\n Row │ cname        total           SE\n     │ String15     Float64         Float64\n─────┼────────────────────────────────────────────\n   1 │ Santa Clara       6.44244e5      4.2273e5\n   2 │ San Diego         1.2276e6       8.62727e5\n   3 │ Merced        70300.2        71336.3\n   4 │ Los Angeles       3.2862e5       2.93936e5\n   5 │ Orange            3.84807e5      3.88014e5\n   6 │ Fresno        63903.1        64781.7\n   7 │ Plumas            2.16147e5      2.12089e5\n   8 │ Alameda      249080.0            2.49228e5\n   9 │ San Joaquin       6.90276e5      6.81604e5\n  10 │ Kern          30631.5        30870.3\n  11 │ Mendocino     84380.6        80215.9\n\n\n\n\n\n","category":"function"},{"location":"api/#Statistics.quantile","page":"API reference","title":"Statistics.quantile","text":"quantile(var, design, p; kwargs...)\n\nEstimate quantile of a variable.\n\nHyndman and Fan compiled a taxonomy of nine algorithms to estimate quantiles. These are implemented in Statistics.quantile, which this function calls. Julia, R and Python-numpy use the same defaults\n\nReferences:\n\nHyndman, R.J and Fan, Y. (1996) \"Sample Quantiles in Statistical Packages\", The American Statistician, Vol. 50, No. 4, pp. 361-365.\nQuantiles on wikipedia\nComplex Surveys: a guide to analysis using R, Section 2.4.1 and Appendix C.4.\n\njulia> apisrs = load_data(\"apisrs\");\n\njulia> srs = SurveyDesign(apisrs; weights=:pw); \n\njulia> quantile(:api00, srs, 0.5)\n1×1 DataFrame\n Row │ 0.5th percentile\n     │ Float64\n─────┼──────────────────\n   1 │            659.0\n\n\n\n\n\nUse replicate weights to compute the standard error of the estimated quantile. \n\njulia> bsrs = srs |> bootweights; \n\njulia> quantile(:api00, bsrs, 0.5)\n1×2 DataFrame\n Row │ 0.5th percentile  SE\n     │ Float64           Float64\n─────┼───────────────────────────\n   1 │            659.0  14.9764\n\n\n\n\n\nquantile(var, design, p; kwargs...)\n\nEstimate quantiles of a list of variables.\n\njulia> quantile(:enroll, srs, [0.1,0.2,0.5,0.75,0.95])\n5×2 DataFrame\n Row │ percentile  statistic\n     │ String      Float64\n─────┼───────────────────────\n   1 │ 0.1             245.5\n   2 │ 0.2             317.6\n   3 │ 0.5             453.0\n   4 │ 0.75            668.5\n   5 │ 0.95           1473.1\n\n\n\n\n\nUse replicate weights to compute the standard errors of the estimated quantiles. \n\njulia> quantile(:enroll, bsrs, [0.1,0.2,0.5,0.75,0.95])\n5×3 DataFrame\n Row │ percentile  statistic  SE       \n     │ String      Float64    Float64  \n─────┼─────────────────────────────────\n   1 │ 0.1             245.5   20.2964\n   2 │ 0.2             317.6   13.5435\n   3 │ 0.5             453.0   24.9719\n   4 │ 0.75            668.5   34.2487\n   5 │ 0.95           1473.1  142.568\n\n\n\n\n\n","category":"function"},{"location":"api/#Survey.ratio","page":"API reference","title":"Survey.ratio","text":"ratio(numerator, denominator, design)\n\nEstimate the ratio of the columns specified in numerator and denominator.\n\njulia> apiclus1 = load_data(\"apiclus1\");\n\njulia> dclus1 = SurveyDesign(apiclus1; clusters = :dnum, weights = :pw);\n\njulia> ratio(:api00, :enroll, dclus1)\n1×1 DataFrame\n Row │ ratio\n     │ Float64\n─────┼─────────\n   1 │ 1.17182\n\n\n\n\n\n\nUse replicate weights to compute the standard error of the ratio.\n\njulia> bclus1 = bootweights(dclus1); \n\njulia> ratio(:api00, :enroll, bclus1)\n1×2 DataFrame\n Row │ ratio    SE\n     │ Float64  Float64\n─────┼───────────────────\n   1 │ 1.17182  0.131518\n\n\n\n\n\n\n","category":"function"},{"location":"api/#Survey.plot","page":"API reference","title":"Survey.plot","text":"plot(design, x, y; kwargs...)\n\nScatter plot of survey design variables x and y.\n\nThe plot takes into account the frequency weights specified by the user in the design.\n\njulia> using AlgebraOfGraphics\n\njulia> apisrs = load_data(\"apisrs\");\n\njulia> srs = SurveyDesign(apisrs; weights=:pw);\n\njulia> s = plot(srs, :api99, :api00);\n\njulia> save(\"scatter.png\", s)\n\n(Image: )\n\n\n\n\n\n","category":"function"},{"location":"api/#Survey.boxplot","page":"API reference","title":"Survey.boxplot","text":"boxplot(design, x, y; kwargs...)\n\nBox plot of survey design variable y grouped by column x.\n\nWeights can be specified by a Symbol using the keyword argument weights.\n\nThe keyword arguments are all the arguments that can be passed to mapping in AlgebraOfGraphics.\n\njulia> using AlgebraOfGraphics\n\njulia> apisrs = load_data(\"apisrs\");\n\njulia> srs = SurveyDesign(apisrs; weights=:pw);\n\njulia> bp = boxplot(srs, :stype, :enroll; weights = :pw);\n\njulia> save(\"boxplot.png\", bp)\n\n(Image: )\n\n\n\n\n\n","category":"function"},{"location":"api/#Survey.hist","page":"API reference","title":"Survey.hist","text":"hist(design, var, bins = freedman_diaconis; normalization = :density, kwargs...)\n\nHistogram plot of a survey design variable given by var.\n\nbins can be an Integer specifying the number of equal-width bins, an AbstractVector specifying the bins intervals, or a Function specifying the function used for calculating the number of bins. The possible functions are sturges and freedman_diaconis.\n\nThe normalization can be set to :none, :density, :probability or :pdf. See AlgebraOfGraphics.histogram for more information.\n\nFor the complete argument list see Makie.hist.\n\nnote: Note\nThe weights argument should be a Symbol specifying a design variable.\n\njulia> using AlgebraOfGraphics\n\njulia> apisrs = load_data(\"apisrs\");\n\njulia> srs = SurveyDesign(apisrs; weights=:pw);\n\njulia> h = hist(srs, :enroll);\n\njulia> save(\"hist.png\", h)\n\n(Image: )\n\n\n\n\n\n","category":"function"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The Survey.jl package is registered. Regular Pkg commands can be used for installing the package:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Pkg\n\nPkg.add(\"Survey\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"]  add Survey","category":"page"},{"location":"getting_started/#Tutorial","page":"Getting Started","title":"Tutorial","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This tutorial assumes basic knowledge of statistics and survey analysis.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To begin this tutorial, load the package in your workspace:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Survey","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Now load a survey dataset that you want to study. In this tutorial we will be using the Academic Performance Index (API) datasets for Californian schools. The datasets contain information for all schools with at least 100 students and for various probability samples of the data.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"apisrs = load_data(\"apisrs\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"apisrs is a simple random sample of the Academic Performance Index of Californian schools. The load_data function loads it as a DataFrame. You can look at the column names of apisrs to get an idea of what the dataset contains.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"names(apisrs)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Next, build a survey design from your DataFrame:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"srs = SurveyDesign(apisrs; weights=:pw)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This is a simple random sample design with weights given by the column :pw of apisrs. You can also create more complex designs such as stratified or cluster sample designs. You can find more information on the complete capabilities of the package in the Manual. The purpose of this tutorial is to show the basic usage of the package. For that, we will stick with a simple random sample.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Now you can analyse your design according to your needs using the functionality provided by the package. For example, you can compute the estimated mean or population total for a given variable. Let's say you want to find the mean Academic Performance Index from the year 1999. If you are only interested in the estimated mean, then you can directly pass your design to the mean function:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"mean(:api99, srs)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"If you also want to know the standard error of the mean, you need to convert the SurveyDesign to a ReplicateDesign using bootstrapping:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"bsrs = bootweights(srs; replicates = 1000)\nmean(:api99, bsrs)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"You can find the mean of both the 1999 API and 2000 API for a clear comparison between students' performance from one year to another:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"mean([:api99, :api00], bsrs)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The ratio is also appropriate for studying the relationship between the two APIs:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"ratio(:api00, :api99, bsrs)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"If you're interested in a certain statistic estimated by a specific domain, you can add the domain as the second parameter to your function. Let's say you want to find the estimated total number of students enrolled in schools from each county:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"total(:enroll, :cname, bsrs)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Another way to visualize data is through graphs. You can make a histogram to better see the distribution of enrolled students:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# !!!THIS NEEDS TO MATCH THE EXAMPLE IN THE DOCSTRING OF `hist`","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> hist(srs, :enroll)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The REPL doesn't show the plot. To see it, you need to save it locally.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> import AlgebraOfGraphics.save\n\njulia> save(\"hist.png\", h)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"man/comparisons/#Comparison-with-other-survey-analysis-tools","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"There are multiple alternatives that offer survey analysis tools, most notably SAS, Stata and R.","category":"page"},{"location":"man/comparisons/#R-comparison","page":"Comparison with other survey analysis tools","title":"R comparison","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"The inspiration for Survey.jl comes from R. Hence the syntax is in most cases very similar to the syntax in the survey package from R. To showcase this we will use the api datasets found in both R's survey and Survey.jl. See the Tutorial section for more details about the api datesets.","category":"page"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"All examples show the R code first, followed by the Julia code.","category":"page"},{"location":"man/comparisons/#Loading-data","page":"Comparison with other survey analysis tools","title":"Loading data","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"> data(api)\n# all `api` datasets are loaded globally","category":"page"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"julia> srs = load_data(\"apisrs\")\n# only one dataset is loaded and stored in a variable","category":"page"},{"location":"man/comparisons/#Creating-a-design","page":"Comparison with other survey analysis tools","title":"Creating a design","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"> srs = svydesign(id=~1, data=apisrs, weights=~pw) # simple random sample\n> dstrat = svydesign(id=~1, data=apistrat, strata=~stype, weights=~pw) # stratified\n> clus1 = svydesign(id=~dnum, data=apiclus1, weights=~pw) # clustered (one stage)","category":"page"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"julia> srs = SurveyDesign(apisrs; weights=:pw) # simple random sample\njulia> dstrat = SurveyDesign(apistrat; strata=:stype, weights=:pw) # stratified\njulia> clus1 = SurveyDesign(apiclus1; clusters=:dnum, weights=:pw) # clustered (one stage)","category":"page"},{"location":"man/comparisons/#Creating-a-replicate-design","page":"Comparison with other survey analysis tools","title":"Creating a replicate design","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"> bsrs = as.svrepdesign(srs, type=\"subbootstrap\")","category":"page"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"julia> bsrs = bootweights(srs)","category":"page"},{"location":"man/comparisons/#Computing-the-estimated-mean","page":"Comparison with other survey analysis tools","title":"Computing the estimated mean","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"> svymean(~api00, bsrs)\n> svymean(~api99+~api00, bsrs)","category":"page"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"julia> mean(:api00, bsrs)\njulia> mean([:api99, :api00], bsrs)","category":"page"},{"location":"man/comparisons/#Computing-the-estimated-total","page":"Comparison with other survey analysis tools","title":"Computing the estimated total","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"> svytotal(~api00, bsrs)\n> svytotal(~api99+~api00, bsrs)","category":"page"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"julia> total(:api00, bsrs)\njulia> total([:api99, :api00], bsrs)","category":"page"},{"location":"man/comparisons/#Computing-quantiles","page":"Comparison with other survey analysis tools","title":"Computing quantiles","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"> svyquantile(~api00, bsrs, 0.5)\n> svyquantile(~api00, bsrs, c(0.25, 0.5, 0.75))","category":"page"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"julia> quantile(:api00, bsrs, 0.5)\njulia> quantile(:api00, bsrs, [0.25, 0.5, 0.75])","category":"page"},{"location":"man/comparisons/#Domain-estimation","page":"Comparison with other survey analysis tools","title":"Domain estimation","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"> svyby(~api00, ~cname, bsrs, svymean)","category":"page"},{"location":"man/comparisons/","page":"Comparison with other survey analysis tools","title":"Comparison with other survey analysis tools","text":"julia> mean(:api00, :cname, bsrs)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Survey","category":"page"},{"location":"#Survey","page":"Home","title":"Survey","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is used to study complex survey data. It aims to provide an efficient computing framework for survey analysis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Surveys are a standard tool for empirical research in social and behavioral sciences, and also widely used by governments and businesses.  To obtain a better representation of a population and more precise estimates, complex surveys use sampling techniques like clustering, stratification, unequal probability selection or a combination of these.  Computing population estimates from a survey with corresponding standard errors requires several corrections, weights calibrations and adjustments. A \"survey\" package automatically applies several of these mathematical techniques and exposes an intuitive API to the user.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Sizes of survey datasets have also been growing with advances in computing power and storage, as well as ease of administering surveys online and over wider geographic areas. This Julia package aims to provide an efficient framework for rapidly growing sizes of survey datasets.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Several software tools are available to study complex surveys[1]. The survey package in R is a widely used open-source package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Discourse post announcing the package.","category":"page"},{"location":"#Current-features","page":"Home","title":"Current features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Presently, summary statistics such as mean, total, ratio, and quantile can be estimated for whole of sample as well as subpopulations/domains using this package. Variance estimation for these estimators are performed using Rao-Wu bootstrap[2]. Basic visualisations such a scatter plot, histogram and box plot can also be generated. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package is built on top of DataFrames.jl and supports a variety of features for data manipulation. Plots are generated using AlgebraOfGraphics.","category":"page"},{"location":"#Plans","page":"Home","title":"Plans","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We plan for efficient implementations of all the methods in R survey. Features for future releases will include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Proportion and count estimation\nVariance by Taylor linearization for SurveyDesign\nSupport additional replicate weighting algorithms (BRR, Jackknife, other bootstrap flavors) for ReplicateDesign\nBetter support for more complex survey designs, including more precise estimators for specific designs\nPost-stratification, raking or calibration, GREG estimation and related methods.\nFrequency/contingency table analysis, association tests\nSurvival curves and analysis tools\nIntegration with GLM.jl\nSupport for CategoricalsArrays\nMultivariate analysis, principal components  \nSupport for imputing missing data\nIntegration with CRRao.jl ","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]: Comprehensive list of survey analysis software.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2]: Rust, Keith F., and J. N. K. Rao. \"Variance estimation for complex surveys using replication techniques.\", Statistical methods in medical research 5.3 (1996): 283-310.","category":"page"},{"location":"man/dataframes/#manual","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"","category":"section"},{"location":"man/dataframes/","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"The internal structure of a survey design is build upon DataFrames. In fact, the data argument is the only required argument for the constructor, and it must be an AbstractDataFrame.","category":"page"},{"location":"man/dataframes/#Data-manipulation","page":"DataFrames in Survey","title":"Data manipulation","text":"","category":"section"},{"location":"man/dataframes/","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"The provided DataFrame is altered by the SurveyDesign constructor in order to add columns for frequency and probability weights, sample and population sizes and, if necessary, strata and cluster information.","category":"page"},{"location":"man/dataframes/","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"Notice the change in apisrs:","category":"page"},{"location":"man/dataframes/","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"using Survey","category":"page"},{"location":"man/dataframes/","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"apisrs = load_data(\"apisrs\")\nnames(apisrs)\nsrs = SurveyDesign(apisrs; weights=:pw);\napisrs\nnames(apisrs)","category":"page"},{"location":"man/dataframes/","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"Five columns were added:","category":"page"},{"location":"man/dataframes/","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"false_strata - only in the case of no stratification\nThis column is necessary because when making a ReplicateDesign, the bootweights function uses groupby with a column representing the stratification variable. If there are no strata, there is no such column, so it should be added in order to keep bootweights general.\nfalse_cluster - only in the case of no clustering\nThe reasoning is the same as in the case of no stratification.\n_sampsize - sample sizes\n_popsize - population sizes\nThese match the stratification variable:","category":"page"},{"location":"man/dataframes/","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"apistrat = load_data(\"apistrat\");\ndstrat = SurveyDesign(apistrat; strata=:stype, weights=:pw);\napistrat[:, [:stype, :_sampsize, :_popsize]]","category":"page"},{"location":"man/dataframes/","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"_allprobs - probability weights","category":"page"},{"location":"man/dataframes/","page":"DataFrames in Survey","title":"DataFrames in Survey","text":"No column was added for frequency weights because the column passed through the weights argument is used by other functions, hence there is no need to add a new column. If weights is not specified, then a column called _weights is added.","category":"page"}]
}
